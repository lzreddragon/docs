"use strict";(self.webpackChunksonic_red_dragon_docs=self.webpackChunksonic_red_dragon_docs||[]).push([[9860],{2373:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>s,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"contracts/governance/ve69lp","title":"ve69LP","description":"Voting escrow contract for LP tokens with time-weighted voting power and non-linear boost","source":"@site/docs/contracts/governance/ve69lp.md","sourceDirName":"contracts/governance","slug":"/contracts/governance/ve69lp","permalink":"/contracts/governance/ve69lp","draft":false,"unlisted":false,"editUrl":"https://github.com/wenakita/sonicreddragon-docs/edit/main/docs/contracts/governance/ve69lp.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1,"title":"ve69LP","description":"Voting escrow contract for LP tokens with time-weighted voting power and non-linear boost"},"sidebar":"contracts","previous":{"title":"Overview","permalink":"/contracts/governance/overview"},"next":{"title":"Voting","permalink":"/contracts/governance/voting"}}');var i=o(4848),r=o(8453);const s={sidebar_position:1,title:"ve69LP",description:"Voting escrow contract for LP tokens with time-weighted voting power and non-linear boost"},a="ve69LP Contract",c={},l=[{value:"Overview",id:"overview",level:2},{value:"Contract Implementation",id:"contract-implementation",level:2},{value:"Core Data Structures",id:"core-data-structures",level:2},{value:"LockedBalance",id:"lockedbalance",level:3},{value:"Point",id:"point",level:3},{value:"Lock Parameters",id:"lock-parameters",level:2},{value:"Core Functions",id:"core-functions",level:2},{value:"Creating a Lock",id:"creating-a-lock",level:3},{value:"Increasing Lock Amount",id:"increasing-lock-amount",level:3},{value:"Extending Lock Duration",id:"extending-lock-duration",level:3},{value:"Withdrawing Tokens",id:"withdrawing-tokens",level:3},{value:"Voting Power Calculation",id:"voting-power-calculation",level:2},{value:"Voting Power Boost Curve",id:"voting-power-boost-curve",level:2},{value:"View Functions",id:"view-functions",level:2},{value:"Lock Flow Example",id:"lock-flow-example",level:2},{value:"Security Features",id:"security-features",level:2},{value:"Integration with Governance",id:"integration-with-governance",level:2},{value:"Mathematical Considerations",id:"mathematical-considerations",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"ve69lp-contract",children:"ve69LP Contract"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"ve69LP"})," contract implements a vote-escrowed token system that allows users to lock their 69/31 LP tokens for a period of time in exchange for voting power in the Sonic Red Dragon ecosystem. This contract follows the veCRV model from Curve Finance, with improved math using cube root scaling for vote weighting."]}),"\n",(0,i.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(n.mermaid,{value:'flowchart TD\n    LPToken["69/31 LP Token"] --\x3e|"Lock tokens"| ve69LP["ve69LP Contract"]\n    ve69LP --\x3e|"Grants"| VotingPower["Voting Power"]\n    ve69LP --\x3e|"Allows"| Governance["Governance Voting"]\n    ve69LP --\x3e|"Earns"| Rewards["Fee Revenue"]\n    TimeLength["Lock Duration"] --\x3e|"Impacts"| VotingMultiplier["Voting Multiplier"]\n    VotingMultiplier --\x3e|"Increases"| VotingPower\n    \n    classDef highlight fill:#4a80d1,stroke:#333,stroke-width:2px,color:white;\n    class ve69LP highlight'}),"\n",(0,i.jsx)(n.p,{children:"The ve69LP system is designed to:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Incentivize Long-Term Holders"}),": Rewards users who commit to locking tokens for extended periods"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Enable Governance Participation"}),": Provides voting power proportional to locked amount and time"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Apply Non-Linear Boost"}),": Uses cube root scaling to balance short and long-term positions"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Distribute Protocol Fees"}),": Serves as the mechanism for fee distribution to protocol supporters"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"contract-implementation",children:"Contract Implementation"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"ve69LP"})," contract implements the ",(0,i.jsx)(n.code,{children:"Ive69LP"})," interface and includes security features:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"contract ve69LP is Ownable, ReentrancyGuard, Ive69LP {\n    using Math for uint256;\n    using SafeCast for uint256;\n    \n    // Constants\n    uint256 private constant WEEK = 7 * 86400;             // 1 week in seconds\n    uint256 private constant MAX_LOCK_TIME = 4 * 365 * 86400; // 4 years in seconds\n    uint256 private constant MIN_LOCK_TIME = 7 * 86400;    // 1 week in seconds\n    uint256 private constant PRECISION = 1e18;             // Precision for calculations\n    \n    // State variables\n    IERC20 public lpToken;    // 69/31 LP token\n    bool public initialized;  // Initialization flag\n    uint256 public totalSupply;       // Total ve69LP supply\n    mapping(address => LockedBalance) public locked;\n    mapping(address => uint256) public userPointEpoch;\n    mapping(address => mapping(uint256 => Point)) public userPointHistory;\n    mapping(uint256 => Point) public pointHistory;\n    \n    // Voting power configuration\n    uint256 public maxVP = 15000;      // Maximum voting power multiplier (2.5x) in basis points\n    uint256 public maxBoost;          // Pre-calculated maximum boost (for gas optimization)\n    \n    uint256 public epoch;\n    \n    // ... more code ...\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"core-data-structures",children:"Core Data Structures"}),"\n",(0,i.jsx)(n.h3,{id:"lockedbalance",children:"LockedBalance"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"struct LockedBalance {\n    uint256 amount;       // Amount of 69/31 LP tokens locked\n    uint256 unlockTime;   // Unix timestamp when tokens unlock\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"LockedBalance"})," struct tracks how many LP tokens a user has locked and when they can be withdrawn."]}),"\n",(0,i.jsx)(n.h3,{id:"point",children:"Point"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"struct Point {\n    uint256 bias;         // Voting power at the time of recording\n    uint256 slope;        // How fast the voting power is decreasing over time\n    uint256 timestamp;    // Time point was recorded\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"Point"})," struct represents a checkpoint in the voting power history, allowing the contract to determine historical voting power for governance snapshots."]}),"\n",(0,i.jsx)(n.h2,{id:"lock-parameters",children:"Lock Parameters"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Parameter"}),(0,i.jsx)(n.th,{children:"Value"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"MIN_LOCK_TIME"})}),(0,i.jsx)(n.td,{children:"1 week"}),(0,i.jsx)(n.td,{children:"Minimum lock duration"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"MAX_LOCK_TIME"})}),(0,i.jsx)(n.td,{children:"4 years"}),(0,i.jsx)(n.td,{children:"Maximum lock duration"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"maxVP"})}),(0,i.jsx)(n.td,{children:"15000 (150%)"}),(0,i.jsx)(n.td,{children:"Maximum voting power boost"})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"core-functions",children:"Core Functions"}),"\n",(0,i.jsx)(n.h3,{id:"creating-a-lock",children:"Creating a Lock"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"function createLock(uint256 lpAmount, uint256 lockDuration) external nonReentrant whenInitialized {\n    if (lpAmount == 0) revert ZeroAmount();\n    \n    // Align lock end time to week boundary using DragonDateTimeLib\n    uint256 unlockTime = DragonDateTimeLib.calculateLockEndAligned(block.timestamp, lockDuration);\n    \n    if (unlockTime <= block.timestamp) revert LockTimeNotInFuture();\n    if (unlockTime - block.timestamp < MIN_LOCK_TIME) revert LockTimeTooShort();\n    if (unlockTime - block.timestamp > MAX_LOCK_TIME) revert LockTimeTooLong();\n\n    LockedBalance storage userLock = locked[msg.sender];\n    if (userLock.amount > 0) revert ExistingLockFound();\n\n    // Transfer tokens to contract\n    bool success = lpToken.transferFrom(msg.sender, address(this), lpAmount);\n    if (!success) revert TransferFailed();\n\n    // Update locked balance\n    userLock.amount = lpAmount;\n    userLock.unlockTime = unlockTime;\n\n    // Calculate voting power\n    uint256 votingPower = calculateVotingPower(lpAmount, unlockTime);\n\n    // Update total supply\n    uint256 prevSupply = totalSupply;\n    totalSupply = prevSupply + votingPower;\n\n    // Update user point history\n    userPointEpoch[msg.sender] += 1;\n    uint256 userEpoch = userPointEpoch[msg.sender];\n    userPointHistory[msg.sender][userEpoch] = Point({\n        bias: votingPower,\n        slope: votingPower / (unlockTime - block.timestamp),\n        timestamp: block.timestamp\n    });\n\n    // Update global point history\n    epoch += 1;\n    pointHistory[epoch] = Point({\n        bias: totalSupply,\n        slope: pointHistory[epoch - 1].slope + (votingPower / (unlockTime - block.timestamp)),\n        timestamp: block.timestamp\n    });\n\n    // Emit Deposit event using the interface parameter names\n    emit Deposit(msg.sender, lpAmount, unlockTime, votingPower);\n    emit Supply(prevSupply, totalSupply);\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"This function allows users to create a new lock by depositing LP tokens and specifying a lock duration. The lock end time is aligned to a week boundary, and voting power is calculated based on the lock amount and duration."}),"\n",(0,i.jsx)(n.h3,{id:"increasing-lock-amount",children:"Increasing Lock Amount"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"function increaseLockAmount(uint256 additionalAmount) external nonReentrant whenInitialized {\n    LockedBalance storage userLocked = locked[msg.sender];\n    \n    if (additionalAmount == 0) revert ZeroAmount();\n    if (userLocked.amount == 0) revert NoLockFound();\n    if (userLocked.unlockTime <= block.timestamp) revert LockExpired();\n    \n    // Checkpoint with new amount but same unlock time\n    _checkpoint(msg.sender, userLocked, LockedBalance({\n        amount: userLocked.amount + additionalAmount,\n        unlockTime: userLocked.unlockTime\n    }));\n    \n    // Update user's lock\n    userLocked.amount += additionalAmount;\n    \n    // Transfer LP tokens from user to contract\n    bool success = lpToken.transferFrom(msg.sender, address(this), additionalAmount);\n    if (!success) revert TransferFailed();\n    \n    uint256 lockTime = userLocked.unlockTime;\n    uint256 votingPower = calculateVotingPower(userLocked.amount, lockTime);\n    \n    // Emit with interface parameters\n    emit Deposit(msg.sender, additionalAmount, lockTime, votingPower);\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Users can add more LP tokens to their existing lock without changing the unlock time. This increases their voting power proportionally."}),"\n",(0,i.jsx)(n.h3,{id:"extending-lock-duration",children:"Extending Lock Duration"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"function extendLock(uint256 lockDuration) external nonReentrant whenInitialized {\n    LockedBalance storage userLock = locked[msg.sender];\n    if (userLock.amount == 0) revert NoLockFound();\n    \n    // Align the new unlock time to a week boundary using DragonDateTimeLib\n    uint256 newUnlockTime = DragonDateTimeLib.calculateLockEndAligned(userLock.unlockTime, lockDuration);\n    \n    if (newUnlockTime <= userLock.unlockTime) revert LockTimeNotInFuture();\n    if (newUnlockTime > block.timestamp + MAX_LOCK_TIME) revert LockTimeTooLong();\n    if (newUnlockTime < block.timestamp + MIN_LOCK_TIME) revert LockTimeTooShort();\n\n    // Calculate old voting power\n    uint256 oldVotingPower = calculateVotingPower(userLock.amount, userLock.unlockTime);\n\n    // Update unlock time\n    userLock.unlockTime = newUnlockTime;\n\n    // Calculate new voting power\n    uint256 newVotingPower = calculateVotingPower(userLock.amount, newUnlockTime);\n\n    // Update user point history\n    userPointEpoch[msg.sender] += 1;\n    uint256 userEpoch = userPointEpoch[msg.sender];\n    userPointHistory[msg.sender][userEpoch] = Point({\n        bias: newVotingPower,\n        slope: 0,\n        timestamp: block.timestamp\n    });\n\n    // Update total supply\n    totalSupply = totalSupply - oldVotingPower + newVotingPower;\n\n    // Update global point history\n    epoch += 1;\n    pointHistory[epoch] = Point({\n        bias: totalSupply,\n        slope: 0,\n        timestamp: block.timestamp\n    });\n\n    // Emit LockUpdated event instead of Deposit\n    emit LockUpdated(msg.sender, lockDuration, newVotingPower);\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Users can extend the duration of their existing lock to increase their voting power. The new unlock time is aligned to a week boundary, and voting power is recalculated."}),"\n",(0,i.jsx)(n.h3,{id:"withdrawing-tokens",children:"Withdrawing Tokens"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"function withdraw() external nonReentrant whenInitialized {\n    LockedBalance storage userLock = locked[msg.sender];\n    if (userLock.amount == 0) revert NoLockFound();\n    if (block.timestamp < userLock.unlockTime) revert LockNotExpired();\n\n    // Save the amount to withdraw\n    uint256 amount = userLock.amount;\n\n    // Clear the lock before any external calls\n    userLock.amount = 0;\n    userLock.unlockTime = 0;\n\n    // Update total supply (voting power should already be 0 since lock expired)\n    uint256 oldVotingPower = calculateVotingPower(amount, userLock.unlockTime);\n    if (oldVotingPower > 0) {\n        totalSupply = totalSupply > oldVotingPower ? totalSupply - oldVotingPower : 0;\n    }\n\n    // Update user point history\n    userPointEpoch[msg.sender] += 1;\n    uint256 userEpoch = userPointEpoch[msg.sender];\n    userPointHistory[msg.sender][userEpoch] = Point({\n        bias: 0,\n        slope: 0,\n        timestamp: block.timestamp\n    });\n\n    // Update global point history\n    epoch += 1;\n    pointHistory[epoch] = Point({\n        bias: totalSupply,\n        slope: 0,\n        timestamp: block.timestamp\n    });\n\n    // Transfer tokens back to user\n    bool success = lpToken.transfer(msg.sender, amount);\n    if (!success) revert TransferFailed();\n\n    emit Withdraw(msg.sender, amount);\n    emit Supply(totalSupply + oldVotingPower, totalSupply);\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Once a lock expires, users can withdraw their LP tokens. This removes their voting power and updates the total supply."}),"\n",(0,i.jsx)(n.h2,{id:"voting-power-calculation",children:"Voting Power Calculation"}),"\n",(0,i.jsx)(n.p,{children:"The ve69LP contract uses a sophisticated voting power calculation that applies a non-linear boost based on lock time:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"function calculateVotingPower(uint256 _amount, uint256 _unlockTime) public view returns (uint256) {\n    if (_amount == 0 || _unlockTime <= block.timestamp) {\n        return 0;\n    }\n    \n    uint256 timeDiff = _unlockTime - block.timestamp;\n    if (timeDiff > MAX_LOCK_TIME) {\n        timeDiff = MAX_LOCK_TIME;\n    }\n    \n    // Calculate time ratio as a percentage of MAX_LOCK_TIME (scaled by 1e18)\n    uint256 timeRatio = (timeDiff * PRECISION) / MAX_LOCK_TIME;\n    \n    // Apply cube root scaling for non-linear boost using project's math library\n    uint256 nonLinearBoost = DragonMathLib.cubeRoot(timeRatio);\n    \n    // Scale nonLinearBoost by maxVP\n    uint256 boostMultiplier = (nonLinearBoost * maxVP) / 10000;\n    \n    // Apply boost cap (cannot exceed maxBoost)\n    if (boostMultiplier > maxBoost) {\n        boostMultiplier = maxBoost;\n    }\n    \n    // Calculate final voting power with the non-linear boost\n    uint256 votingPower = (_amount * (10000 + boostMultiplier)) / 10000;\n    \n    return votingPower;\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"This calculation:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Determines the time ratio of the lock as a percentage of the maximum lock time"}),"\n",(0,i.jsx)(n.li,{children:"Applies cube root scaling to create a non-linear boost"}),"\n",(0,i.jsx)(n.li,{children:"Scales the boost by the maximum voting power multiplier (maxVP)"}),"\n",(0,i.jsx)(n.li,{children:"Caps the boost at the maximum allowed boost"}),"\n",(0,i.jsx)(n.li,{children:"Applies the boost to the locked amount to determine voting power"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"voting-power-boost-curve",children:"Voting Power Boost Curve"}),"\n",(0,i.jsx)(n.p,{children:"The non-linear boost creates a curve that incentivizes longer lock durations while still providing meaningful voting power for shorter locks:"}),"\n",(0,i.jsx)(n.mermaid,{value:'xychart-beta\n    title "Voting Power Multiplier by Lock Duration"\n    x-axis "Lock Duration (Years)" [0, 1, 2, 3, 4]\n    y-axis "Multiplier" 1 --\x3e 2.5\n    line [1, 1.42, 1.78, 2.13, 2.5]'}),"\n",(0,i.jsx)(n.p,{children:"The cube root scaling provides these benefits:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"More significant initial boost for shorter lock periods (encouraging participation)"}),"\n",(0,i.jsx)(n.li,{children:"Diminishing returns for extremely long locks (avoiding excessive concentration of power)"}),"\n",(0,i.jsx)(n.li,{children:"Smooth progression that avoids arbitrary thresholds"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"view-functions",children:"View Functions"}),"\n",(0,i.jsx)(n.p,{children:"The contract provides several view functions to query voting power and lock information:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"// Get current voting power of a user\nfunction votingPowerOf(address _user) external view returns (uint256);\n\n// Get historical voting power at a specific timestamp\nfunction getVotingPowerAt(address user, uint256 timestamp) external view returns (uint256);\n\n// Get total voting power\nfunction getTotalVotingPower() external view returns (uint256);\n\n// Get lock information for a user\nfunction getUserLock(address user) external view returns (uint256 amount, uint256 end);\n\n// Check if a user has an active lock\nfunction hasActiveLock(address _user) external view returns (bool);\n"})}),"\n",(0,i.jsx)(n.p,{children:"These functions enable:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Governance mechanisms to calculate voting power for proposals"}),"\n",(0,i.jsx)(n.li,{children:"User interfaces to display lock information"}),"\n",(0,i.jsx)(n.li,{children:"Historical voting power queries for snapshot-based voting"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"lock-flow-example",children:"Lock Flow Example"}),"\n",(0,i.jsx)(n.mermaid,{value:"sequenceDiagram\n    participant User\n    participant LPToken as LP Token\n    participant ve69LP as ve69LP Contract\n    participant Governance as Governance System\n    \n    User->>LPToken: Approve(ve69LP, amount)\n    User->>ve69LP: createLock(amount, duration)\n    ve69LP->>LPToken: transferFrom(user, ve69LP, amount)\n    ve69LP->>ve69LP: Calculate voting power\n    ve69LP->>ve69LP: Update user point history\n    ve69LP->>ve69LP: Update global point history\n    \n    Note over User, ve69LP: Lock Active Period\n    \n    Governance->>ve69LP: getVotingPower(user)\n    ve69LP--\x3e>Governance: Return voting power\n    Governance->>User: Allow voting with power\n    \n    Note over User, ve69LP: Time Passes...\n    \n    alt Extend Lock\n        User->>ve69LP: extendLock(newDuration)\n        ve69LP->>ve69LP: Recalculate voting power\n        ve69LP->>ve69LP: Update histories\n    else Increase Amount\n        User->>LPToken: Approve(ve69LP, additionalAmount)\n        User->>ve69LP: increaseLockAmount(additionalAmount)\n        ve69LP->>LPToken: transferFrom(user, ve69LP, additionalAmount)\n        ve69LP->>ve69LP: Recalculate voting power\n        ve69LP->>ve69LP: Update histories\n    end\n    \n    Note over User, ve69LP: Lock Expires\n    \n    User->>ve69LP: withdraw()\n    ve69LP->>ve69LP: Set voting power to 0\n    ve69LP->>LPToken: transfer(user, amount)"}),"\n",(0,i.jsx)(n.h2,{id:"security-features",children:"Security Features"}),"\n",(0,i.jsx)(n.p,{children:"The contract implements multiple security features:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"ReentrancyGuard"}),": Prevents reentrant calls during token transfers"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Ownership Controls"}),": Restricts sensitive functions to the contract owner"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Clear State Management"}),": Updates state before external calls to prevent reentrancy issues"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Weekly Alignment"}),": Aligns all locks to weekly boundaries for predictable behavior"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Checkpoint System"}),": Records state changes to enable accurate historical queries"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"integration-with-governance",children:"Integration with Governance"}),"\n",(0,i.jsx)(n.p,{children:"The ve69LP contract serves as the foundation for the governance system, enabling:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Proposal Voting"}),": Users with voting power can vote on governance proposals"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Fee Distribution"}),": Protocol fees can be distributed proportional to voting power"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Parameter Tuning"}),": Governance can adjust protocol parameters through voting"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Treasury Management"}),": Governance can direct treasury funds through voting"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"mathematical-considerations",children:"Mathematical Considerations"}),"\n",(0,i.jsx)(n.p,{children:"The ve69LP implementation includes several mathematical optimizations:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Cube Root Scaling"}),": Provides a balanced non-linear boost that rewards longer locks without overly penalizing shorter ones"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Pre-Calculated Maximum Boost"}),": Optimizes gas usage by pre-computing the maximum possible boost"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Precision Management"}),": Uses appropriate scaling factors to maintain precision in calculations"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Slope-Based Decay"}),": Tracks how voting power decreases over time using slopes for efficient calculation"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,o)=>{o.d(n,{R:()=>s,x:()=>a});var t=o(6540);const i={},r=t.createContext(i);function s(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);