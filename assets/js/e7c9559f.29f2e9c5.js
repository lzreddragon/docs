"use strict";(self.webpackChunksonic_red_dragon_docs=self.webpackChunksonic_red_dragon_docs||[]).push([[8992],{2321:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>d,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"contracts/oracles/vrf-integrator","title":"DragonVRFIntegrator","description":"The DragonVRFIntegrator contract serves as a bridge between external randomness sources (like drand networks) and the OmniDragon ecosystem, providing a standardized interface for consuming randomness.","source":"@site/docs/contracts/oracles/vrf-integrator.md","sourceDirName":"contracts/oracles","slug":"/contracts/oracles/vrf-integrator","permalink":"/contracts/oracles/vrf-integrator","draft":false,"unlisted":false,"editUrl":"https://github.com/wenakita/sonicreddragon-docs/edit/main/docs/contracts/oracles/vrf-integrator.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"contracts","previous":{"title":"OmniDragonVRFConsumer","permalink":"/contracts/oracles/vrf-consumer"},"next":{"title":"DragonVRFLib","permalink":"/contracts/oracles/vrf-lib"}}');var s=r(4848),a=r(8453);const o={sidebar_position:2},i="DragonVRFIntegrator",d={},l=[{value:"Overview",id:"overview",level:2},{value:"Key Features",id:"key-features",level:2},{value:"Contract Implementation",id:"contract-implementation",level:2},{value:"Randomness Management",id:"randomness-management",level:2},{value:"Consumer Management",id:"consumer-management",level:2},{value:"Randomness Fulfillment",id:"randomness-fulfillment",level:2},{value:"Security Features",id:"security-features",level:2},{value:"Deployment and Configuration",id:"deployment-and-configuration",level:2},{value:"Deployment for a drand Network",id:"deployment-for-a-drand-network",level:3},{value:"Deployment for Chainlink VRF",id:"deployment-for-chainlink-vrf",level:3},{value:"Integration with Relay Services",id:"integration-with-relay-services",level:2},{value:"Consumer Interface",id:"consumer-interface",level:2},{value:"Usage Example",id:"usage-example",level:2},{value:"Advanced Usage: Direct Verification",id:"advanced-usage-direct-verification",level:2}];function c(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"dragonvrfintegrator",children:"DragonVRFIntegrator"})}),"\n",(0,s.jsxs)(e.p,{children:["The ",(0,s.jsx)(e.code,{children:"DragonVRFIntegrator"})," contract serves as a bridge between external randomness sources (like drand networks) and the OmniDragon ecosystem, providing a standardized interface for consuming randomness."]}),"\n",(0,s.jsx)(e.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(e.p,{children:"This contract is responsible for integrating with a specific randomness source, handling the verification and delivery of random values to consumer contracts:"}),"\n",(0,s.jsx)(e.mermaid,{value:'flowchart TB\n    ExternalSource["External Randomness Source<br>(drand/Chainlink/etc)"] --\x3e|"Random Values"| Relay["Relay Service"]\n    Relay --\x3e|"Verified Randomness"| DragonVRFIntegrator\n    \n    DragonVRFIntegrator --\x3e|"Latest Randomness"| OmniConsumer["OmniDragonVRFConsumer"]\n    DragonVRFIntegrator --\x3e|"Direct Fulfillment"| SingleConsumer["Single Source Consumer"]\n    \n    subgraph "DragonVRFIntegrator"\n        Storage["Randomness Storage"]\n        Auth["Access Control"]\n        Interface["Consumer Interface"]\n        Update["Update Logic"]\n    end\n    \n    classDef highlight fill:#4a80d1,stroke:#333,stroke-width:2px,color:white;\n    class DragonVRFIntegrator,Storage highlight'}),"\n",(0,s.jsx)(e.h2,{id:"key-features",children:"Key Features"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Source Integration"}),": Connects to a specific randomness source (e.g., drand, Chainlink)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Verified Storage"}),": Stores the latest verified randomness value"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Access Control"}),": Restricts randomness updates to authorized entities"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Consumer Management"}),": Manages authorized consumer contracts"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Direct Fulfillment"}),": Can directly fulfill randomness for simple consumers"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"contract-implementation",children:"Contract Implementation"}),"\n",(0,s.jsx)(e.p,{children:"The core of the DragonVRFIntegrator is implemented as follows:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-solidity",children:'// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Ownable} from "../lib/access/Ownable.sol";\nimport {ReentrancyGuard} from "../lib/security/ReentrancyGuard.sol";\nimport "./interfaces/IDragonVRFIntegrator.sol";\nimport "./interfaces/IDragonVRFConsumer.sol";\n\n/**\n * @title DragonVRFIntegrator\n * @dev Integrates drand randomness network with Dragon ecosystem\n */\ncontract DragonVRFIntegrator is Ownable, ReentrancyGuard, IDragonVRFIntegrator {\n    // drand network information\n    uint256 public latestDrandRound;\n    uint256 public latestDrandValue;\n    uint256 public lastUpdateTimestamp;\n    \n    // Consumer information\n    mapping(address => bool) public authorizedConsumers;\n    \n    // Events\n    event RandomnessUpdated(uint256 round, uint256 value);\n    event ConsumerAuthorized(address consumer, bool authorized);\n}\n'})}),"\n",(0,s.jsx)(e.h2,{id:"randomness-management",children:"Randomness Management"}),"\n",(0,s.jsx)(e.p,{children:"The contract provides functions to update and retrieve randomness:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-solidity",children:'/**\n * @dev Updates the randomness value (only callable by owner)\n * @param _round The drand round number\n * @param _value The randomness value\n */\nfunction updateRandomness(uint256 _round, uint256 _value) external onlyOwner {\n    require(_round > latestDrandRound, "Round must be newer");\n    \n    latestDrandRound = _round;\n    latestDrandValue = _value;\n    lastUpdateTimestamp = block.timestamp;\n    \n    emit RandomnessUpdated(_round, _value);\n}\n\n/**\n * @dev Returns the latest randomness value\n */\nfunction getLatestRandomness() external view override returns (uint256, uint256) {\n    return (latestDrandValue, latestDrandRound);\n}\n'})}),"\n",(0,s.jsx)(e.h2,{id:"consumer-management",children:"Consumer Management"}),"\n",(0,s.jsx)(e.p,{children:"The contract manages authorized consumers through these functions:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-solidity",children:"/**\n * @dev Authorizes a consumer to request randomness\n * @param _consumer The consumer address\n * @param _authorized Whether to authorize or deauthorize\n */\nfunction setAuthorizedConsumer(address _consumer, bool _authorized) external onlyOwner {\n    authorizedConsumers[_consumer] = _authorized;\n    emit ConsumerAuthorized(_consumer, _authorized);\n}\n"})}),"\n",(0,s.jsx)(e.h2,{id:"randomness-fulfillment",children:"Randomness Fulfillment"}),"\n",(0,s.jsx)(e.p,{children:"For direct consumers, the contract provides a fulfillment function:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-solidity",children:'/**\n * @dev Allows a consumer to request randomness (only callable by authorized consumers)\n * @param _requestId The requestId to fulfill \n */\nfunction fulfillRandomness(uint256 _requestId) external override nonReentrant {\n    require(authorizedConsumers[msg.sender], "Not authorized");\n    \n    // Send the randomness back to the consumer\n    IDragonVRFConsumer(msg.sender).fulfillRandomness(_requestId, latestDrandValue, latestDrandRound);\n}\n'})}),"\n",(0,s.jsx)(e.h2,{id:"security-features",children:"Security Features"}),"\n",(0,s.jsx)(e.p,{children:"The DragonVRFIntegrator implements several security measures:"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Access Control"}),": Only authorized entities can update randomness"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-solidity",children:'function updateRandomness(uint256 _round, uint256 _value) external onlyOwner {\n    require(_round > latestDrandRound, "Round must be newer");\n    // ...\n}\n'})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Consumer Authorization"}),": Only authorized consumers can request randomness"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-solidity",children:'function fulfillRandomness(uint256 _requestId) external override nonReentrant {\n    require(authorizedConsumers[msg.sender], "Not authorized");\n    // ...\n}\n'})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Reentrancy Protection"}),": Uses ReentrancyGuard to prevent reentrancy attacks"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-solidity",children:"function fulfillRandomness(uint256 _requestId) external override nonReentrant {\n    // ...\n}\n"})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Round Validation"}),": Ensures only newer rounds can update randomness"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-solidity",children:'require(_round > latestDrandRound, "Round must be newer");\n'})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"deployment-and-configuration",children:"Deployment and Configuration"}),"\n",(0,s.jsx)(e.h3,{id:"deployment-for-a-drand-network",children:"Deployment for a drand Network"}),"\n",(0,s.jsx)(e.p,{children:"To deploy an integrator for a drand network:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-solidity",children:"// Deploy the integrator\nDragonVRFIntegrator integrator = new DragonVRFIntegrator();\n\n// Configure the drand relay (off-chain component)\n// This component fetches data from the drand network and calls updateRandomness\n\n// Authorize consumers\nintegrator.setAuthorizedConsumer(omniConsumerAddress, true);\n"})}),"\n",(0,s.jsx)(e.h3,{id:"deployment-for-chainlink-vrf",children:"Deployment for Chainlink VRF"}),"\n",(0,s.jsx)(e.p,{children:"For a Chainlink VRF source, the deployment would be slightly different:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-solidity",children:"// Deploy the Chainlink integrator\nChainlinkVRFIntegrator integrator = new ChainlinkVRFIntegrator(\n    vrfCoordinator,\n    linkToken,\n    keyHash,\n    fee\n);\n\n// Authorize consumers\nintegrator.setAuthorizedConsumer(omniConsumerAddress, true);\n"})}),"\n",(0,s.jsx)(e.h2,{id:"integration-with-relay-services",children:"Integration with Relay Services"}),"\n",(0,s.jsx)(e.p,{children:"The DragonVRFIntegrator is typically used with an off-chain relay service that:"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"Monitors the external randomness source"}),"\n",(0,s.jsx)(e.li,{children:"Verifies randomness values"}),"\n",(0,s.jsx)(e.li,{children:"Submits verified randomness to the integrator contract"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"For drand networks, this relay service:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Subscribes to drand beacon outputs"}),"\n",(0,s.jsx)(e.li,{children:"Verifies BLS signatures"}),"\n",(0,s.jsxs)(e.li,{children:["Submits verified randomness rounds via ",(0,s.jsx)(e.code,{children:"updateRandomness()"})]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"consumer-interface",children:"Consumer Interface"}),"\n",(0,s.jsx)(e.p,{children:"To use the DragonVRFIntegrator directly, consumer contracts should implement:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-solidity",children:"interface IDragonVRFConsumer {\n    function fulfillRandomness(uint256 requestId, uint256 randomness, uint256 round) external;\n}\n"})}),"\n",(0,s.jsx)(e.h2,{id:"usage-example",children:"Usage Example"}),"\n",(0,s.jsx)(e.p,{children:"Here's how a contract would use the DragonVRFIntegrator directly:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-solidity",children:'// Simple consumer that uses a single randomness source\ncontract SingleSourceConsumer is IDragonVRFConsumer {\n    IDragonVRFIntegrator public integrator;\n    \n    mapping(uint256 => bool) public pendingRequests;\n    uint256 public lastRandomValue;\n    uint256 private nextRequestId = 1;\n    \n    constructor(address _integrator) {\n        integrator = IDragonVRFIntegrator(_integrator);\n    }\n    \n    // Request randomness\n    function getRandomNumber() external returns (uint256) {\n        uint256 requestId = nextRequestId++;\n        pendingRequests[requestId] = true;\n        \n        // Request fulfillment from the integrator\n        integrator.fulfillRandomness(requestId);\n        \n        return requestId;\n    }\n    \n    // Called by the integrator to fulfill randomness\n    function fulfillRandomness(uint256 requestId, uint256 randomness, uint256 round) external override {\n        require(msg.sender == address(integrator), "Only integrator can fulfill");\n        require(pendingRequests[requestId], "Request not found");\n        \n        lastRandomValue = randomness;\n        delete pendingRequests[requestId];\n        \n        // Use randomness here\n    }\n}\n'})}),"\n",(0,s.jsx)(e.h2,{id:"advanced-usage-direct-verification",children:"Advanced Usage: Direct Verification"}),"\n",(0,s.jsx)(e.p,{children:"For advanced use cases, the integrator can be extended to perform direct on-chain verification of randomness:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-solidity",children:'// Example for on-chain drand verification\nfunction verifyAndUpdateRandomness(\n    uint256 round,\n    bytes calldata signature,\n    bytes32 previousSignatureHash\n) external {\n    // Verify the signature\n    bool isValid = drandVerifier.verify(\n        drandPublicKey,\n        signature,\n        previousSignatureHash,\n        round\n    );\n    \n    require(isValid, "Invalid signature");\n    \n    // Calculate randomness value from signature\n    uint256 randomness = uint256(keccak256(signature));\n    \n    // Update randomness\n    latestDrandRound = round;\n    latestDrandValue = randomness;\n    lastUpdateTimestamp = block.timestamp;\n    \n    emit RandomnessUpdated(round, randomness);\n}\n'})})]})}function u(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(c,{...n})}):c(n)}},8453:(n,e,r)=>{r.d(e,{R:()=>o,x:()=>i});var t=r(6540);const s={},a=t.createContext(s);function o(n){const e=t.useContext(a);return t.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function i(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:o(n.components),t.createElement(a.Provider,{value:e},n.children)}}}]);