"use strict";(self.webpackChunksonic_red_dragon_docs=self.webpackChunksonic_red_dragon_docs||[]).push([[9250],{1462:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>p,frontMatter:()=>a,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"contracts/core/token","title":"OmniDragon Token","description":"The main ERC20 token with cross-chain functionality, fee distributions, and jackpot system","source":"@site/docs/contracts/core/token.md","sourceDirName":"contracts/core","slug":"/contracts/core/token","permalink":"/contracts/core/token","draft":false,"unlisted":false,"editUrl":"https://github.com/wenakita/sonicreddragon-docs/edit/main/docs/contracts/core/token.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1,"title":"OmniDragon Token","description":"The main ERC20 token with cross-chain functionality, fee distributions, and jackpot system"},"sidebar":"contracts","previous":{"title":"Smart Contracts Overview","permalink":"/contracts/overview"},"next":{"title":"Periphery","permalink":"/contracts/core/periphery"}}');var i=r(4848),s=r(8453);const a={sidebar_position:1,title:"OmniDragon Token",description:"The main ERC20 token with cross-chain functionality, fee distributions, and jackpot system"},o="OmniDragon Token",d={},l=[{value:"Overview",id:"overview",level:2},{value:"Contract Implementation",id:"contract-implementation",level:2},{value:"Token Supply and Constants",id:"token-supply-and-constants",level:2},{value:"Fee Structure",id:"fee-structure",level:2},{value:"Cross-Chain Functionality",id:"cross-chain-functionality",level:2},{value:"Jackpot and Lottery System",id:"jackpot-and-lottery-system",level:2},{value:"Token Transfers and Fee Application",id:"token-transfers-and-fee-application",level:2},{value:"Automatic Liquidity",id:"automatic-liquidity",level:2},{value:"Partner Integration",id:"partner-integration",level:2},{value:"Security Features",id:"security-features",level:2},{value:"Error Types",id:"error-types",level:2},{value:"Constructor and Initialization",id:"constructor-and-initialization",level:2},{value:"Multi-Chain Deployment",id:"multi-chain-deployment",level:2},{value:"Token Flow Example",id:"token-flow-example",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"omnidragon-token",children:"OmniDragon Token"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"OmniDragon"})," token is the central component of the Sonic Red Dragon ecosystem. It's an ERC20 token with advanced features including cross-chain functionality, automated fee distributions, and integration with the jackpot lottery system."]}),"\n",(0,i.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(n.mermaid,{value:'flowchart TD\n    Token["OmniDragon Token"] --\x3e LZ["LayerZero V2"]\n    Token --\x3e Governance["ve69LP Governance"]\n    Token --\x3e JackpotSystem["Jackpot System"]\n    \n    subgraph "Cross-Chain Infrastructure"\n        LZ\n        MessageLib["Message Library"]\n        Endpoint["LZ Endpoint"]\n    end\n    \n    subgraph "Governance System"\n        Governance\n        Voting["Voting"]\n        Treasury["Treasury"]\n    end\n    \n    subgraph "Lottery & Jackpot"\n        JackpotSystem\n        SwapOracle["Swap Trigger Oracle"]\n        JackpotVault["Jackpot Vault"]\n        Distributor["Jackpot Distributor"]\n    end\n    \n    Token --\x3e|"6.9% fee"| JackpotVault\n    Token --\x3e|"2.41% fee"| Treasury\n    Token --\x3e|"0.69% fee"| Burn["Token Burn"]\n    \n    classDef highlight fill:#4a80d1,stroke:#333,stroke-width:2px,color:white;\n    class Token highlight'}),"\n",(0,i.jsx)(n.h2,{id:"contract-implementation",children:"Contract Implementation"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"OmniDragon"})," token implements several interfaces and inherits from core OpenZeppelin contracts:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"contract OmniDragon is ERC20, Ownable, ReentrancyGuard, IOmniDragon {\n    using SafeERC20 for IERC20;\n\n    // ======== Storage ========\n    address public lzEndpoint;       // LayerZero endpoint\n    address public jackpotVault;     // Jackpot vault\n    address public revenueDistributor;  // Primary fee distributor\n    address public wrappedNativeToken;    // WrappedNativeToken/WETH\n    address public swapTrigger;      // Swap trigger for lottery entries\n    address public chainRegistry;    // Chain registry for chain ID verification\n    address public uniswapRouter;    // Uniswap router address\n    address public immutable thisAddress; // This contract's address\n    \n    // Dragon Partners integration\n    address public dragonPartnerRegistry;  // Registry for partner addresses\n    address public dragonPartnerFactory;   // Factory for creating partner pools\n    \n    // Fee structures\n    struct Fees {\n        uint256 jackpot;\n        uint256 ve69LP;\n        uint256 burn;\n        uint256 total;\n    }\n    \n    Fees public buyFees;\n    Fees public sellFees;\n    Fees public transferFees;\n    \n    // Multi-DEX support\n    enum DexType { UNKNOWN, UNISWAP_V2, UNISWAP_V3, BALANCER, CURVE }\n    \n    // Constants\n    uint256 public constant MAX_SUPPLY = 6942000 * 10**18;   // Max supply (6.942 million)\n    uint256 public constant INITIAL_SUPPLY = 6942000 * 10**18; // Initial supply to mint\n    uint16 public constant SONIC_CHAIN_ID = 332;  // Sonic's LayerZero chain ID\n    \n    // ... additional storage variables ...\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"token-supply-and-constants",children:"Token Supply and Constants"}),"\n",(0,i.jsx)(n.p,{children:"The token has a fixed maximum supply and various configuration constants:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"// Constants\nuint256 public constant MAX_SUPPLY = 6942000 * 10**18;   // Max supply (6.942 million)\nuint256 public constant INITIAL_SUPPLY = 6942000 * 10**18; // Initial supply to mint\nuint16 public constant SONIC_CHAIN_ID = 332;  // Sonic's LayerZero chain ID\n"})}),"\n",(0,i.jsx)(n.h2,{id:"fee-structure",children:"Fee Structure"}),"\n",(0,i.jsx)(n.p,{children:"The token implements a sophisticated fee structure with different rates for buys, sells, and transfers:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"// Fee structures\nstruct Fees {\n    uint256 jackpot;\n    uint256 ve69LP;\n    uint256 burn;\n    uint256 total;\n}\n\nFees public buyFees;\nFees public sellFees;\nFees public transferFees;\n"})}),"\n",(0,i.jsx)(n.p,{children:"The default fee configuration is:"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Fee Type"}),(0,i.jsx)(n.th,{children:"Buy"}),(0,i.jsx)(n.th,{children:"Sell"}),(0,i.jsx)(n.th,{children:"Transfer"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Jackpot"}),(0,i.jsx)(n.td,{children:"6.9%"}),(0,i.jsx)(n.td,{children:"6.9%"}),(0,i.jsx)(n.td,{children:"0%"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"ve69LP"}),(0,i.jsx)(n.td,{children:"2.41%"}),(0,i.jsx)(n.td,{children:"2.41%"}),(0,i.jsx)(n.td,{children:"0%"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Burn"}),(0,i.jsx)(n.td,{children:"0.69%"}),(0,i.jsx)(n.td,{children:"0.69%"}),(0,i.jsx)(n.td,{children:"0.69%"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Total"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"10%"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"10%"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"0.69%"})})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"cross-chain-functionality",children:"Cross-Chain Functionality"}),"\n",(0,i.jsx)(n.p,{children:"The token integrates with LayerZero to enable seamless cross-chain transfers:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"/**\n * @dev OFTv2 functionality: Send tokens to another chain\n */\nfunction sendTokens(\n    uint16 _dstChainId, \n    bytes32 _toAddress, \n    uint _amount, \n    address payable _refundAddress, \n    address _zroPaymentAddress, \n    bytes calldata _adapterParams\n) external payable {\n    _debitFrom(msg.sender, _amount);\n    \n    bytes memory payload = abi.encode(_toAddress, _amount);\n    \n    _lzSend(\n        _dstChainId,\n        payload,\n        _refundAddress,\n        _zroPaymentAddress,\n        _adapterParams\n    );\n    \n    emit SendToChain(_dstChainId, msg.sender, abi.encodePacked(_toAddress), _amount);\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Key cross-chain features include:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Chain ID Verification"}),": Integration with ChainRegistry for secure chain identification"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Trusted Remote Setting"}),": Configuration for trusted contracts on other chains"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Fee Estimation"}),": Ability to estimate cross-chain transfer fees"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"LayerZero V2 Compatibility"}),": Latest OFT protocol compatibility"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"jackpot-and-lottery-system",children:"Jackpot and Lottery System"}),"\n",(0,i.jsx)(n.p,{children:"The token integrates with the jackpot system through several mechanisms:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"/**\n * @dev Process potential jackpot entry on token buy (swap)\n * @param user The user who performed the swap\n * @param amount The amount being swapped\n */\nfunction _processPotentialJackpotEntry(address user, uint256 amount) internal {\n    // Only process if swap trigger is set and not excluded from fees\n    if (swapTrigger != address(0) && !isExcludedFromFees[user]) {\n        // Call the swap trigger oracle\n        try IOmniDragonSwapTriggerOracle(swapTrigger).onSwap(user, amount) {\n            // Success, entry processed\n        } catch {\n            // Failed to process entry, but we don't want to revert the swap\n        }\n    }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"The jackpot system works by:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Recording transaction events in the SwapTriggerOracle"}),"\n",(0,i.jsx)(n.li,{children:"Assigning win probabilities based on swap amount and market conditions"}),"\n",(0,i.jsx)(n.li,{children:"Sending a portion of fees (6.9%) to the jackpot vault"}),"\n",(0,i.jsx)(n.li,{children:"Allowing jackpot distribution through the dedicated distributor contract"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"token-transfers-and-fee-application",children:"Token Transfers and Fee Application"}),"\n",(0,i.jsx)(n.p,{children:"The token overrides the standard ERC20 transfer functions to apply fees:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"/**\n * @dev Override ERC20 _transfer to apply fees and special handling\n */\nfunction _transfer(\n    address sender,\n    address recipient,\n    uint256 amount\n) internal override {\n    // Check if transfers are paused\n    if (transfersPaused) revert TransfersPaused();\n    \n    // Check for zero inputs\n    if (sender == address(0)) revert ZeroAddress();\n    if (recipient == address(0)) revert ZeroAddress();\n    if (amount == 0) revert ZeroAmount();\n\n    // Handle swap accumulation and auto-liquidity\n    if (!inSwap && swapEnabled && \n        !isExcludedFromFees[sender] && \n        !isExcludedFromFees[recipient]) {\n        // Auto-swap processing\n        _processSwapIfNeeded();\n    }\n    \n    // Determine if fees should be taken\n    bool takeFee = feesEnabled && \n                   !isExcludedFromFees[sender] && \n                   !isExcludedFromFees[recipient];\n                \n    // Detect transaction type and apply appropriate fees\n    if (takeFee) {\n        if (isPair[sender]) {\n            // This is a buy (from pair to user)\n            _transferWithFees(sender, recipient, amount, buyFees);\n            \n            // Process potential jackpot entry on buy\n            _processPotentialJackpotEntry(recipient, amount);\n            \n        } else if (isPair[recipient]) {\n            // This is a sell (from user to pair)\n            _transferWithFees(sender, recipient, amount, sellFees);\n            \n        } else {\n            // This is a regular transfer between wallets\n            _transferWithFees(sender, recipient, amount, transferFees);\n        }\n    } else {\n        // No fees, standard transfer\n        super._transfer(sender, recipient, amount);\n    }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"automatic-liquidity",children:"Automatic Liquidity"}),"\n",(0,i.jsx)(n.p,{children:"The contract implements automatic liquidity management:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"/**\n * @dev Swap accumulated tokens for native tokens and add liquidity\n */\nfunction _swapAndLiquify() private lockTheSwap {\n    // Cache the amount to be swapped\n    uint256 contractTokenBalance = balanceOf(address(this));\n    \n    // Check if we have enough accumulated tokens\n    if (contractTokenBalance >= minimumAmountForProcessing) {\n        // Convert half to wrapped native token\n        uint256 halfForLiquidity = contractTokenBalance / 2;\n        uint256 otherHalf = contractTokenBalance - halfForLiquidity;\n        \n        // Get initial wrapped native token balance\n        uint256 initialWrappedNativeBalance = IERC20(wrappedNativeToken).balanceOf(address(this));\n        \n        // Swap tokens for wrapped native token\n        _swapTokensForWrappedNative(halfForLiquidity);\n        \n        // Get the amount of wrapped native token received\n        uint256 wrappedNativeReceived = IERC20(wrappedNativeToken).balanceOf(address(this)) - initialWrappedNativeBalance;\n        \n        // Add liquidity to DEX\n        if (wrappedNativeReceived > 0) {\n            _addLiquidity(otherHalf, wrappedNativeReceived);\n            \n            emit SwapAndLiquify(halfForLiquidity, wrappedNativeReceived);\n        }\n    }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"partner-integration",children:"Partner Integration"}),"\n",(0,i.jsx)(n.p,{children:"The token includes functionality for partner integrations:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"/**\n * @dev Register a partner pool\n * @param _pool Partner pool address\n * @param _partnerId Partner ID\n */\nfunction registerPartnerPool(address _pool, uint256 _partnerId) external onlyOwner {\n    if (_pool == address(0)) revert ZeroAddress();\n    if (isPartnerPool[_pool]) revert PartnerPoolAlreadyRegistered();\n    \n    isPartnerPool[_pool] = true;\n    partnerPoolIds[_pool] = _partnerId;\n    \n    // Exclude partner pool from fees\n    isExcludedFromFees[_pool] = true;\n    \n    emit PartnerPoolRegistered(_pool, _partnerId);\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"security-features",children:"Security Features"}),"\n",(0,i.jsx)(n.p,{children:"The contract implements multiple security features:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"ReentrancyGuard"}),": Protection against reentrancy attacks"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Ownership Controls"}),": Restricts critical functions to the owner"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Error Handling"}),": Explicit error types for all potential failures"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Fee Exemptions"}),": Ability to exclude addresses from fees"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Swap Lock"}),": Prevents reentrant swaps during liquidity operations"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Emergency Pause"}),": Ability to pause transfers in emergency situations"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"error-types",children:"Error Types"}),"\n",(0,i.jsx)(n.p,{children:"The contract defines specific error types for clear failure identification:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"// ======== Errors ========\nerror JackpotVaultZeroAddress();\nerror RevenueDistributorZeroAddress();\nerror WrappedNativeTokenNotSet();\nerror LzEndpointZeroAddress();\nerror ChainRegistryZeroAddress();\nerror ZeroAddress();\nerror ZeroAmount();\nerror NotAuthorized();\nerror RegistrationFailed();\nerror InvalidEndpoint();\nerror InvalidPayload();\nerror InvalidSource();\nerror AlreadyConfigured();\nerror NotSonicChain();\nerror InitialMintingAlreadyDone();\nerror MaxSupplyExceeded();\nerror InvalidSender();\nerror InvalidInputAmount();\nerror InvalidOutputAmount();\nerror TransfersPaused();\nerror InsufficientWrappedNativeBalance();\nerror CannotRecoverDragonTokens();\nerror DragonPartnerRegistryZeroAddress();\nerror DragonPartnerFactoryZeroAddress();\nerror PartnerPoolAlreadyRegistered();\nerror PartnerPoolNotFound();\nerror NotPartnerPool();\n"})}),"\n",(0,i.jsx)(n.h2,{id:"constructor-and-initialization",children:"Constructor and Initialization"}),"\n",(0,i.jsx)(n.p,{children:"The token is initialized with a specific supply and configuration:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"/**\n * @dev Constructor to initialize the token\n */\nconstructor(\n    string memory _name,\n    string memory _symbol,\n    address _jackpotVault,\n    address _revenueDistributor,\n    address _lzEndpoint,\n    address _chainRegistry\n) ERC20(_name, _symbol) Ownable() {\n    if (_jackpotVault == address(0)) revert JackpotVaultZeroAddress();\n    if (_revenueDistributor == address(0)) revert RevenueDistributorZeroAddress();\n    if (_lzEndpoint == address(0)) revert InvalidEndpoint();\n    if (_chainRegistry == address(0)) revert ChainRegistryZeroAddress();\n    \n    jackpotVault = _jackpotVault;\n    revenueDistributor = _revenueDistributor;\n    lzEndpoint = _lzEndpoint;\n    chainRegistry = _chainRegistry;\n    thisAddress = address(this);\n    \n    // Use deployer address as placeholder for wrapped native token\n    wrappedNativeToken = msg.sender;\n    \n    // Initialize flag values\n    feesEnabled = true;\n    swapEnabled = true;\n    \n    // Set up default fees\n    // Buy fees (10%)\n    buyFees.jackpot = 690; // 6.9%\n    buyFees.ve69LP = 241; // 2.41%\n    buyFees.burn = 69;  // 0.69%\n    buyFees.total = 1000; // 10%\n    \n    // ... additional initialization ...\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"multi-chain-deployment",children:"Multi-Chain Deployment"}),"\n",(0,i.jsx)(n.p,{children:"The token is deployed on multiple chains with identical functionality:"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Chain"}),(0,i.jsx)(n.th,{children:"Layer Type"}),(0,i.jsx)(n.th,{children:"Chain ID"}),(0,i.jsx)(n.th,{children:"LZ Chain ID"}),(0,i.jsx)(n.th,{children:"Primary Use Cases"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Ethereum"}),(0,i.jsx)(n.td,{children:"L1"}),(0,i.jsx)(n.td,{children:"1"}),(0,i.jsx)(n.td,{children:"101"}),(0,i.jsx)(n.td,{children:"Governance, Security, Prime Liquidity"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Sonic"}),(0,i.jsx)(n.td,{children:"L1"}),(0,i.jsx)(n.td,{children:"146"}),(0,i.jsx)(n.td,{children:"332"}),(0,i.jsx)(n.td,{children:"High Throughput, Lower Fees"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Arbitrum"}),(0,i.jsx)(n.td,{children:"L2"}),(0,i.jsx)(n.td,{children:"42161"}),(0,i.jsx)(n.td,{children:"110"}),(0,i.jsx)(n.td,{children:"Scaling, Lower Fees"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Avalanche"}),(0,i.jsx)(n.td,{children:"L1"}),(0,i.jsx)(n.td,{children:"43114"}),(0,i.jsx)(n.td,{children:"106"}),(0,i.jsx)(n.td,{children:"Fast Finality, EVM Compatible"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Base"}),(0,i.jsx)(n.td,{children:"L2"}),(0,i.jsx)(n.td,{children:"8453"}),(0,i.jsx)(n.td,{children:"184"}),(0,i.jsx)(n.td,{children:"Scaling, Lower Fees"})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"token-flow-example",children:"Token Flow Example"}),"\n",(0,i.jsx)(n.mermaid,{value:"sequenceDiagram\n    participant User\n    participant DEX as DEX (Uniswap)\n    participant Token as OmniDragon Token\n    participant Jackpot as Jackpot Vault\n    participant Treasury as ve69LP Treasury\n    \n    User->>DEX: Swap ETH for DRAGON\n    DEX->>Token: Call transfer()\n    \n    Note over Token: Apply 10% buy fee\n    \n    Token->>Token: Calculate fees\n    Token->>Jackpot: Send 6.9% to jackpot\n    Token->>Treasury: Send 2.41% to treasury\n    Token->>Token: Burn 0.69% of tokens\n    \n    Token->>Token: Process jackpot entry\n    Token->>User: Deliver remaining tokens"})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>o});var t=r(6540);const i={},s=t.createContext(i);function a(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);