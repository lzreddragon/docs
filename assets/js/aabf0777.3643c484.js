"use strict";(self.webpackChunksonic_red_dragon_docs=self.webpackChunksonic_red_dragon_docs||[]).push([[4216],{50:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>o,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"contracts/jackpot/distributor","title":"DragonJackpotDistributor","description":"The jackpot distribution system that manages lottery prize winners and payouts","source":"@site/docs/contracts/jackpot/distributor.md","sourceDirName":"contracts/jackpot","slug":"/contracts/jackpot/distributor","permalink":"/contracts/jackpot/distributor","draft":false,"unlisted":false,"editUrl":"https://github.com/wenakita/sonicreddragon-docs/edit/main/docs/contracts/jackpot/distributor.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"title":"DragonJackpotDistributor","description":"The jackpot distribution system that manages lottery prize winners and payouts"},"sidebar":"contracts","previous":{"title":"DragonJackpotVault","permalink":"/contracts/jackpot/vault"},"next":{"title":"Swap Trigger Oracle","permalink":"/contracts/jackpot/trigger"}}');var r=i(4848),s=i(8453);const o={sidebar_position:2,title:"DragonJackpotDistributor",description:"The jackpot distribution system that manages lottery prize winners and payouts"},a="DragonJackpotDistributor",c={},d=[{value:"Overview",id:"overview",level:2},{value:"Contract Implementation",id:"contract-implementation",level:2},{value:"Key Configuration Parameters",id:"key-configuration-parameters",level:2},{value:"Core Functions",id:"core-functions",level:2},{value:"Jackpot Funding",id:"jackpot-funding",level:3},{value:"Prize Distribution",id:"prize-distribution",level:3},{value:"Multi-Recipient Distribution",id:"multi-recipient-distribution",level:3},{value:"Emergency Controls",id:"emergency-controls",level:3},{value:"Rate Limiting Mechanism",id:"rate-limiting-mechanism",level:2},{value:"Configuration Functions",id:"configuration-functions",level:2},{value:"View Functions",id:"view-functions",level:2},{value:"Security Features",id:"security-features",level:2},{value:"Integration Points",id:"integration-points",level:2},{value:"Jackpot Distribution Flow",id:"jackpot-distribution-flow",level:2}];function l(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"dragonjackpotdistributor",children:"DragonJackpotDistributor"})}),"\n",(0,r.jsxs)(e.p,{children:["The ",(0,r.jsx)(e.code,{children:"DragonJackpotDistributor"})," contract is responsible for managing the distribution of jackpot prizes within the Sonic Red Dragon ecosystem. It handles winner selection rules, prize calculation, and the secure delivery of rewards."]}),"\n",(0,r.jsx)(e.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsx)(e.mermaid,{value:'flowchart TD\n    OmniDragon["OmniDragon Token"] --\x3e|"Funds"| Distributor["DragonJackpotDistributor"]\n    SwapOracle["Swap Trigger Oracle"] --\x3e|"Selects Winners"| Distributor\n    Distributor --\x3e|"Sends Prizes"| Winners["Lottery Winners"]\n    Distributor --\x3e|"Records History"| History["Jackpot History"]\n    \n    classDef highlight fill:#4a80d1,stroke:#333,stroke-width:2px,color:white;\n    class Distributor highlight'}),"\n",(0,r.jsx)(e.p,{children:"The distributor manages the entire jackpot lifecycle:"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Fund Accumulation"}),": Collects tokens from transactions and direct contributions"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Prize Distribution"}),": Calculates appropriate prize amounts and delivers to winners"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Rate Limiting"}),": Ensures fair distribution with limits on frequency and amount"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"History Tracking"}),": Maintains a complete record of all jackpot winners"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Emergency Controls"}),": Includes safety features for unexpected situations"]}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"contract-implementation",children:"Contract Implementation"}),"\n",(0,r.jsxs)(e.p,{children:["The ",(0,r.jsx)(e.code,{children:"DragonJackpotDistributor"})," contract implements several interfaces and includes security features:"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-solidity",children:"contract DragonJackpotDistributor is IDragonJackpotDistributor, Ownable, ReentrancyGuard, Pausable {\n    using SafeERC20 for IERC20;\n    using DragonTokenUtils for IERC20;\n    \n    // Constants\n    uint256 public constant PERCENTAGE_DENOMINATOR = 10000; // 100% = 10000\n    \n    // State variables\n    IERC20 public token; // The token to distribute\n    address public treasury; // Treasury wallet for emergency functions\n    address public swapTriggerOracle; // The swap trigger oracle contract\n    uint256 public minJackpotSize; // Minimum size a jackpot must reach before distribution\n    uint256 public distributionPercentage = 6900; // 69% of jackpot per win\n    uint256 public maxWinnersPerPeriod = 3; // Maximum number of winners per period\n    uint256 public jackpotBalance; // Current jackpot balance\n    uint256 public lastDistributionTime; // Last time a jackpot was distributed\n    uint256 public periodDuration = 1 days; // Duration of a distribution period\n    \n    // ... additional state variables and structs ...\n}\n"})}),"\n",(0,r.jsx)(e.h2,{id:"key-configuration-parameters",children:"Key Configuration Parameters"}),"\n",(0,r.jsxs)(e.table,{children:[(0,r.jsx)(e.thead,{children:(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.th,{children:"Parameter"}),(0,r.jsx)(e.th,{children:"Description"}),(0,r.jsx)(e.th,{children:"Default"}),(0,r.jsx)(e.th,{children:"Adjustable?"})]})}),(0,r.jsxs)(e.tbody,{children:[(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"distributionPercentage"})}),(0,r.jsx)(e.td,{children:"Percentage of jackpot given per win (basis points)"}),(0,r.jsx)(e.td,{children:"6900 (69%)"}),(0,r.jsx)(e.td,{children:"\u2713"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"maxWinnersPerPeriod"})}),(0,r.jsx)(e.td,{children:"Maximum winners allowed per period"}),(0,r.jsx)(e.td,{children:"3"}),(0,r.jsx)(e.td,{children:"\u2713"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"periodDuration"})}),(0,r.jsx)(e.td,{children:"Duration of each distribution period"}),(0,r.jsx)(e.td,{children:"1 day"}),(0,r.jsx)(e.td,{children:"\u2713"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"minJackpotSize"})}),(0,r.jsx)(e.td,{children:"Minimum jackpot size before distribution"}),(0,r.jsx)(e.td,{children:"Configurable"}),(0,r.jsx)(e.td,{children:"\u2713"})]})]})]}),"\n",(0,r.jsx)(e.h2,{id:"core-functions",children:"Core Functions"}),"\n",(0,r.jsx)(e.h3,{id:"jackpot-funding",children:"Jackpot Funding"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-solidity",children:"/**\n * @dev Add funds to the jackpot\n * @param amount Amount to add\n */\nfunction addToJackpot(uint256 amount) external override {\n    // Transfer tokens from sender to contract\n    token.safeTransferFrom(msg.sender, address(this), amount);\n    \n    // Update jackpot balance\n    jackpotBalance += amount;\n    \n    emit JackpotAdded(amount, jackpotBalance);\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"This function allows any authorized address to add funds to the jackpot pool. The tokens are transferred from the sender to the contract, and the jackpot balance is updated accordingly."}),"\n",(0,r.jsx)(e.h3,{id:"prize-distribution",children:"Prize Distribution"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-solidity",children:'/**\n * @dev Distribute a jackpot to a winner\n * @param winner Address of the winner\n * @param amount Amount to distribute\n */\nfunction distributeJackpot(address winner, uint256 amount) external override onlyAuthorized nonReentrant whenNotPaused {\n    require(winner != address(0), "Winner cannot be zero address");\n    \n    // Check jackpot size\n    require(jackpotBalance >= minJackpotSize, "Jackpot too small");\n    \n    // Check max winners per period\n    if (block.timestamp >= currentPeriodStart + periodDuration) {\n        // Start a new period\n        currentPeriodStart = block.timestamp;\n        winnersInCurrentPeriod = 0;\n    }\n    \n    require(winnersInCurrentPeriod < maxWinnersPerPeriod, "Max winners reached for current period");\n    \n    // Calculate distribution amount (capped by percentage)\n    uint256 maxDistribution = (jackpotBalance * distributionPercentage) / PERCENTAGE_DENOMINATOR;\n    uint256 distributionAmount = amount > maxDistribution ? maxDistribution : amount;\n    \n    // Update balances and counters\n    jackpotBalance -= distributionAmount;\n    totalDistributed += distributionAmount;\n    winnersInCurrentPeriod++;\n    lastDistributionTime = block.timestamp;\n    \n    // Record win in history\n    jackpotHistory.push(JackpotWin({\n        winner: winner,\n        amount: distributionAmount,\n        timestamp: block.timestamp\n    }));\n    \n    // Transfer tokens to winner\n    token.safeTransfer(winner, distributionAmount);\n    \n    emit JackpotDistributed(winner, distributionAmount, block.timestamp);\n}\n'})}),"\n",(0,r.jsx)(e.p,{children:"This is the core function that handles jackpot distribution. It includes several important controls:"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Authorization Check"}),": Only authorized distributors can call this function"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Jackpot Size Check"}),": Ensures the jackpot has reached minimum size"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Rate Limiting"}),": Manages the number of winners per time period"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Amount Calculation"}),": Ensures distribution follows percentage rules"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"History Tracking"}),": Records win details for transparency"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Secure Transfer"}),": Safely transfers tokens to the winner"]}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"multi-recipient-distribution",children:"Multi-Recipient Distribution"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-solidity",children:'/**\n * @dev Distribute rewards to multiple recipients by basis points\n * @param amount Amount to distribute\n * @param recipients Array of recipient addresses\n * @param basisPoints Array of basis points for each recipient (totaling 10000)\n */\nfunction distributeRewards(\n    uint256 amount, \n    address[] memory recipients, \n    uint256[] memory basisPoints\n) external onlyOwner nonReentrant whenNotPaused {\n    require(jackpotBalance >= amount, "Insufficient balance");\n    \n    // Update jackpot balance\n    jackpotBalance -= amount;\n    \n    // Using the optimized distribution function\n    DragonTokenUtils.distributeByBasisPoints(\n        token,\n        amount,\n        recipients,\n        basisPoints\n    );\n}\n'})}),"\n",(0,r.jsx)(e.p,{children:"This function enables more complex prize distributions where multiple recipients receive proportional shares of a prize pool, useful for team-based competitions or tiered reward structures."}),"\n",(0,r.jsx)(e.h3,{id:"emergency-controls",children:"Emergency Controls"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-solidity",children:"/**\n * @dev Emergency withdraw all funds to treasury\n */\nfunction emergencyWithdraw() external onlyOwner {\n    uint256 balance = token.balanceOf(address(this));\n    \n    // Use the optimized token utility for better gas efficiency\n    DragonTokenUtils.safeTransferTokenOrNative(\n        address(token),\n        treasury,\n        balance\n    );\n    \n    jackpotBalance = 0;\n    \n    emit EmergencyWithdrawal(treasury, balance);\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"The contract includes emergency functions that allow the owner to:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Withdraw all funds to the treasury in case of critical issues"}),"\n",(0,r.jsx)(e.li,{children:"Pause/unpause the distribution system"}),"\n",(0,r.jsx)(e.li,{children:"Batch transfer multiple tokens if needed"}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"rate-limiting-mechanism",children:"Rate Limiting Mechanism"}),"\n",(0,r.jsx)(e.p,{children:"To prevent jackpot depletion and maintain sustainable prizes, the distributor implements a time-based rate limiting system:"}),"\n",(0,r.jsx)(e.mermaid,{value:"sequenceDiagram\n    participant Time as Timeline\n    participant Period as Distribution Period\n    participant Winners as Winner Counter\n    participant Jackpot as Jackpot Balance\n    \n    Note over Period: New Period Starts\n    Period->>Winners: Reset Counter (0)\n    \n    loop Within Period Duration (1 day)\n        Time->>Period: New Winner Selected\n        alt If Winners < Max (3)\n            Period->>Winners: Increment Counter\n            Winners->>Jackpot: Distribute Prize (69%)\n        else If Winners >= Max\n            Period->>Time: Reject Winner\n        end\n    end\n    \n    Note over Period: Period Ends (After 1 day)\n    Time->>Period: New Period Starts\n    Period->>Winners: Reset Counter (0)"}),"\n",(0,r.jsx)(e.p,{children:"This mechanism ensures:"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsx)(e.li,{children:"No more than 3 winners per day by default"}),"\n",(0,r.jsx)(e.li,{children:"Each winner receives a maximum of 69% of the current jackpot"}),"\n",(0,r.jsx)(e.li,{children:"The jackpot can recover between distributions"}),"\n",(0,r.jsx)(e.li,{children:"The system automatically resets after each period"}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"configuration-functions",children:"Configuration Functions"}),"\n",(0,r.jsx)(e.p,{children:"The contract includes several owner-only functions for configuring the distribution parameters:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-solidity",children:"function setMinJackpotSize(uint256 _minJackpotSize) external onlyOwner;\nfunction setDistributionPercentage(uint256 _percentage) external onlyOwner;\nfunction setMaxWinnersPerPeriod(uint256 _maxWinners) external onlyOwner;\nfunction setPeriodDuration(uint256 _duration) external onlyOwner;\nfunction setAuthorizedDistributor(address _distributor, bool _authorized) external onlyOwner;\nfunction setToken(address _token) external onlyOwner;\nfunction setTreasury(address _treasury) external onlyOwner;\n"})}),"\n",(0,r.jsx)(e.p,{children:"These functions allow adaptation of the jackpot system to different market conditions and user behavior patterns."}),"\n",(0,r.jsx)(e.h2,{id:"view-functions",children:"View Functions"}),"\n",(0,r.jsx)(e.p,{children:"The contract provides several view functions for querying jackpot information:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-solidity",children:'/**\n * @dev Get the current jackpot balance\n * @return Current jackpot balance\n */\nfunction getCurrentJackpot() external view override returns (uint256) {\n    return jackpotBalance;\n}\n\n/**\n * @dev Get a jackpot win by index\n * @param index Index of the win\n * @return Winner, amount, and timestamp\n */\nfunction getJackpotHistory(uint256 index) external view returns (\n    address winner,\n    uint256 amount,\n    uint256 timestamp\n) {\n    require(index < jackpotHistory.length, "Invalid index");\n    JackpotWin memory win = jackpotHistory[index];\n    return (win.winner, win.amount, win.timestamp);\n}\n\n/**\n * @dev Get jackpot history count\n * @return Number of jackpot history entries\n */\nfunction getJackpotHistoryCount() external view returns (uint256) {\n    return jackpotHistory.length;\n}\n'})}),"\n",(0,r.jsx)(e.p,{children:"These functions enable:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Frontend display of current jackpot size"}),"\n",(0,r.jsx)(e.li,{children:"Historical record viewing"}),"\n",(0,r.jsx)(e.li,{children:"Statistical analysis of past distributions"}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"security-features",children:"Security Features"}),"\n",(0,r.jsx)(e.p,{children:"The contract implements multiple security features:"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"ReentrancyGuard"}),": Prevents reentrant calls during token transfers"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Pausable"}),": Allows emergency pausing of all distribution functions"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Ownership Controls"}),": Restricts sensitive functions to the contract owner"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"SafeERC20"}),": Uses safe transfer methods to prevent token handling issues"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"DragonTokenUtils"}),": Leverages optimized token utilities for gas efficiency"]}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"integration-points",children:"Integration Points"}),"\n",(0,r.jsx)(e.p,{children:"The distributor integrates with several other system components:"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Token Contract"}),": Receives funds from the token contract"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Swap Trigger Oracle"}),": Receives winner selections from the oracle"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Treasury"}),": Emergency fund recipient"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Client Applications"}),": Provides data for jackpot displays and history"]}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"jackpot-distribution-flow",children:"Jackpot Distribution Flow"}),"\n",(0,r.jsx)(e.mermaid,{value:"sequenceDiagram\n    participant User\n    participant Oracle as Swap Trigger Oracle\n    participant Distributor as Jackpot Distributor\n    participant Vault as Jackpot Vault\n    participant Winner\n    \n    User->>Oracle: Makes qualifying transaction\n    Oracle->>Oracle: Determines win using probability\n    \n    alt User wins jackpot\n        Oracle->>Distributor: Select winner (user)\n        \n        Distributor->>Distributor: Check if jackpot is large enough\n        Distributor->>Distributor: Check period winner limits\n        \n        alt Checks pass\n            Distributor->>Distributor: Calculate prize (69% of pool)\n            Distributor->>Distributor: Record win in history\n            Distributor->>Winner: Transfer prize tokens\n            Distributor->>Distributor: Update counters and balances\n        else Checks fail\n            Distributor--\x3e>Oracle: Reject distribution\n        end\n    end"}),"\n",(0,r.jsx)(e.p,{children:"This flow ensures winners are selected fairly, prizes are distributed correctly, and the system maintains sustainability through rate limiting and percentage-based distributions."})]})}function u(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(l,{...n})}):l(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>o,x:()=>a});var t=i(6540);const r={},s=t.createContext(r);function o(n){const e=t.useContext(s);return t.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:o(n.components),t.createElement(s.Provider,{value:e},n.children)}}}]);