"use strict";(self.webpackChunksonic_red_dragon_docs=self.webpackChunksonic_red_dragon_docs||[]).push([[4423],{5537:(e,n,t)=>{t.d(n,{A:()=>y});var i=t(6540),r=t(4164),a=t(5627),o=t(6347),s=t(372),l=t(604),c=t(1861),u=t(8749);function d(e){return i.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,i.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function p(e){const{values:n,children:t}=e;return(0,i.useMemo)((()=>{const e=n??function(e){return d(e).map((({props:{value:e,label:n,attributes:t,default:i}})=>({value:e,label:n,attributes:t,default:i})))}(t);return function(e){const n=(0,c.XI)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,t])}function h({value:e,tabValues:n}){return n.some((n=>n.value===e))}function m({queryString:e=!1,groupId:n}){const t=(0,o.W6)(),r=function({queryString:e=!1,groupId:n}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:e,groupId:n});return[(0,l.aZ)(r),(0,i.useCallback)((e=>{if(!r)return;const n=new URLSearchParams(t.location.search);n.set(r,e),t.replace({...t.location,search:n.toString()})}),[r,t])]}function g(e){const{defaultValue:n,queryString:t=!1,groupId:r}=e,a=p(e),[o,l]=(0,i.useState)((()=>function({defaultValue:e,tabValues:n}){if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!h({value:e,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const t=n.find((e=>e.default))??n[0];if(!t)throw new Error("Unexpected error: 0 tabValues");return t.value}({defaultValue:n,tabValues:a}))),[c,d]=m({queryString:t,groupId:r}),[g,v]=function({groupId:e}){const n=function(e){return e?`docusaurus.tab.${e}`:null}(e),[t,r]=(0,u.Dv)(n);return[t,(0,i.useCallback)((e=>{n&&r.set(e)}),[n,r])]}({groupId:r}),f=(()=>{const e=c??g;return h({value:e,tabValues:a})?e:null})();(0,s.A)((()=>{f&&l(f)}),[f]);return{selectedValue:o,selectValue:(0,i.useCallback)((e=>{if(!h({value:e,tabValues:a}))throw new Error(`Can't select invalid tab value=${e}`);l(e),d(e),v(e)}),[d,v,a]),tabValues:a}}var v=t(9136);const f={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var b=t(4848);function x({className:e,block:n,selectedValue:t,selectValue:i,tabValues:o}){const s=[],{blockElementScrollPositionUntilNextRender:l}=(0,a.a_)(),c=e=>{const n=e.currentTarget,r=s.indexOf(n),a=o[r].value;a!==t&&(l(n),i(a))},u=e=>{let n=null;switch(e.key){case"Enter":c(e);break;case"ArrowRight":{const t=s.indexOf(e.currentTarget)+1;n=s[t]??s[0];break}case"ArrowLeft":{const t=s.indexOf(e.currentTarget)-1;n=s[t]??s[s.length-1];break}}n?.focus()};return(0,b.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.A)("tabs",{"tabs--block":n},e),children:o.map((({value:e,label:n,attributes:i})=>(0,b.jsx)("li",{role:"tab",tabIndex:t===e?0:-1,"aria-selected":t===e,ref:e=>{s.push(e)},onKeyDown:u,onClick:c,...i,className:(0,r.A)("tabs__item",f.tabItem,i?.className,{"tabs__item--active":t===e}),children:n??e},e)))})}function w({lazy:e,children:n,selectedValue:t}){const a=(Array.isArray(n)?n:[n]).filter(Boolean);if(e){const e=a.find((e=>e.props.value===t));return e?(0,i.cloneElement)(e,{className:(0,r.A)("margin-top--md",e.props.className)}):null}return(0,b.jsx)("div",{className:"margin-top--md",children:a.map(((e,n)=>(0,i.cloneElement)(e,{key:n,hidden:e.props.value!==t})))})}function j(e){const n=g(e);return(0,b.jsxs)("div",{className:(0,r.A)("tabs-container",f.tabList),children:[(0,b.jsx)(x,{...n,...e}),(0,b.jsx)(w,{...n,...e})]})}function y(e){const n=(0,v.A)();return(0,b.jsx)(j,{...e,children:d(e.children)},String(n))}},5914:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"contracts/math/dragon-math-lib","title":"DragonMathLib","description":"Core mathematics library providing essential operations and calculations","source":"@site/docs/contracts/math/dragon-math-lib.md","sourceDirName":"contracts/math","slug":"/contracts/math/dragon-math-lib","permalink":"/contracts/math/dragon-math-lib","draft":false,"unlisted":false,"editUrl":"https://github.com/wenakita/sonicreddragon-docs/edit/main/docs/contracts/math/dragon-math-lib.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"title":"DragonMathLib","description":"Core mathematics library providing essential operations and calculations"},"sidebar":"contracts","previous":{"title":"Mathematical Framework","permalink":"/contracts/math/overview"},"next":{"title":"HermesMath","permalink":"/contracts/math/hermes-math"}}');var r=t(4848),a=t(8453);t(5537),t(9329);const o={sidebar_position:2,title:"DragonMathLib",description:"Core mathematics library providing essential operations and calculations"},s="DragonMathLib",l={},c=[{value:"Overview",id:"overview",level:2},{value:"Key Functions",id:"key-functions",level:2},{value:"Cube Root Calculation",id:"cube-root-calculation",level:3},{value:"Voting Power Calculation",id:"voting-power-calculation",level:3},{value:"Percentage Calculation",id:"percentage-calculation",level:3},{value:"Boost Application",id:"boost-application",level:3},{value:"Weighted Average Calculation",id:"weighted-average-calculation",level:3},{value:"Range Mapping",id:"range-mapping",level:3},{value:"Linear Interpolation",id:"linear-interpolation",level:3},{value:"Usage Examples",id:"usage-examples",level:2},{value:"Governance Voting Power",id:"governance-voting-power",level:3},{value:"Dynamic Pricing Model",id:"dynamic-pricing-model",level:3},{value:"Gas Optimization",id:"gas-optimization",level:2},{value:"Security Considerations",id:"security-considerations",level:2}];function u(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"dragonmathlib",children:"DragonMathLib"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Core mathematics library providing essential operations and calculations"})}),"\n",(0,r.jsxs)("div",{className:"contract-badges",children:[(0,r.jsx)("span",{className:"contract-badge utility",children:"Utility Library"}),(0,r.jsx)("span",{className:"contract-badge core",children:"Core Component"}),(0,r.jsx)("span",{className:"contract-badge optimized",children:"Gas Optimized"})]}),"\n",(0,r.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsx)(n.p,{children:"This library contains optimized mathematical operations for critical protocol functions, especially focusing on voting power calculation, precise percentage math, and interpolation:"}),"\n",(0,r.jsx)(n.mermaid,{value:'flowchart TB\n    subgraph "DragonMathLib Functions"\n        cubeRoot["cubeRoot()<br>Newton\'s method implementation"]\n        votingPower["calculateVotingPower()<br>Governance calculations"]\n        percentage["calculatePercentage()<br>Precise percentages"]\n        boost["applyBoost()<br>Multiplier application"]\n        weighted["calculateWeightedAverage()<br>Combining values"]\n        range["mapRange()<br>Range transformation"]\n        interp["linearInterpolation()<br>Value interpolation"]\n    end\n    \n    subgraph "Protocol Applications"\n        governance["Governance System"]\n        jackpot["Jackpot Distribution"]\n        market["Market Functions"]\n        token["Token Economics"]\n    end\n    \n    cubeRoot --\x3e votingPower\n    votingPower --\x3e governance\n    percentage --\x3e jackpot\n    percentage --\x3e market\n    boost --\x3e token\n    weighted --\x3e jackpot\n    range --\x3e market\n    interp --\x3e market\n    \n    classDef highlight fill:#4a80d1,stroke:#333,stroke-width:2px,color:white;\n    class cubeRoot,votingPower highlight'}),"\n",(0,r.jsx)(n.h2,{id:"key-functions",children:"Key Functions"}),"\n",(0,r.jsx)(n.h3,{id:"cube-root-calculation",children:"Cube Root Calculation"}),"\n",(0,r.jsx)(n.p,{children:"The library implements an optimized cube root function using Newton's method:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-solidity",children:"/**\n * @dev Calculate cube root using Newton's method (used in voting power calculations)\n * @param n The number to find the cube root of\n * @return The cube root of n, with precision\n */\nfunction cubeRoot(uint256 n) internal pure returns (uint256) {\n    if (n == 0) return 0;\n    \n    // Use improved initial guess for faster convergence\n    uint256 x;\n    if (n <= PRECISION) {\n        // For values <= 1, start with a value close to 1\n        x = (n + 2 * PRECISION) / 3;\n    } else {\n        // For values > 1, use a logarithmic approximation for initial guess\n        uint256 log2n = 0;\n        uint256 temp = n;\n        while (temp > PRECISION) {\n            temp = temp / 2;\n            log2n++;\n        }\n        x = 1 << (log2n / 3);\n        \n        // Ensure x is not zero (fallback)\n        if (x == 0) x = n / 3;\n    }\n    \n    // Apply Newton's method with improved convergence check\n    for (uint256 i = 0; i < 8; i++) {\n        // Implementation details...\n    }\n    \n    return x;\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"This implementation features several optimizations:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Smart initial guess selection based on input range"}),"\n",(0,r.jsx)(n.li,{children:"Logarithmic approximation for large numbers"}),"\n",(0,r.jsx)(n.li,{children:"Early exit on convergence"}),"\n",(0,r.jsx)(n.li,{children:"Precision loss prevention"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"voting-power-calculation",children:"Voting Power Calculation"}),"\n",(0,r.jsx)(n.p,{children:"A core function for the governance system that uses cube root normalization:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-solidity",children:"/**\n * @dev Calculate voting power using cube root normalization for more equitable distribution\n * @param amount The amount of tokens\n * @return votingPower The calculated voting power\n */\nfunction calculateVotingPower(uint256 amount) internal pure returns (uint256 votingPower) {\n    if (amount == 0) return 0;\n    \n    // Use cube root for more equitable voting power distribution\n    return cubeRoot(amount * PRECISION) * 100;\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:'This function implements the "cube root rule" (similar to the Wyoming Rule in political science) that creates a more equitable distribution of voting power, preventing large token holders from having disproportionate influence.'}),"\n",(0,r.jsx)(n.h3,{id:"percentage-calculation",children:"Percentage Calculation"}),"\n",(0,r.jsx)(n.p,{children:"Precise percentage calculation with configurable precision:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-solidity",children:"/**\n * @dev Calculate normalized percentage with high precision\n * @param numerator Numerator value\n * @param denominator Denominator value\n * @param precision Precision factor (e.g., 1e18)\n * @return Percentage with specified precision\n */\nfunction calculatePercentage(\n    uint256 numerator, \n    uint256 denominator, \n    uint256 precision\n) internal pure returns (uint256) {\n    if (denominator == 0) return 0;\n    return (numerator * precision) / denominator;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"boost-application",children:"Boost Application"}),"\n",(0,r.jsx)(n.p,{children:"Apply multipliers to values with precision control:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-solidity",children:"/**\n * @dev Apply a boost multiplier to an amount with precise math\n * @param amount Base amount\n * @param multiplier Boost multiplier (scaled by precision)\n * @param precision Precision factor (e.g., 10000 for 100.00%)\n * @return boostedAmount The amount after applying the boost\n */\nfunction applyBoost(\n    uint256 amount, \n    uint256 multiplier, \n    uint256 precision\n) internal pure returns (uint256 boostedAmount) {\n    return (amount * multiplier) / precision;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"weighted-average-calculation",children:"Weighted Average Calculation"}),"\n",(0,r.jsx)(n.p,{children:"Combine multiple values with different weights:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-solidity",children:"/**\n * @dev Calculate weighted average of multiple values\n * @param values Array of values\n * @param weights Array of weights (should sum to precision)\n * @param precision Precision factor (e.g., 1e18)\n * @return weightedAvg Weighted average with specified precision\n */\nfunction calculateWeightedAverage(\n    uint256[] memory values, \n    uint256[] memory weights, \n    uint256 precision\n) internal pure returns (uint256 weightedAvg) {\n    if (values.length != weights.length) revert ArrayLengthMismatch();\n    if (values.length == 0) return 0;\n    \n    uint256 sum = 0;\n    uint256 weightSum = 0;\n    \n    for (uint256 i = 0; i < values.length; i++) {\n        sum += (values[i] * weights[i]);\n        weightSum += weights[i];\n    }\n    \n    // Check to avoid division by zero\n    if (weightSum == 0) return 0;\n    \n    // If weights don't sum to precision, normalize them\n    if (weightSum != precision) {\n        return sum / weightSum;\n    } else {\n        return sum / precision;\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"range-mapping",children:"Range Mapping"}),"\n",(0,r.jsx)(n.p,{children:"Transform values from one range to another:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-solidity",children:"/**\n * @dev Map a value from one range to another with precise math\n * @param value Input value\n * @param fromLow Lower bound of input range\n * @param fromHigh Upper bound of input range\n * @param toLow Lower bound of output range\n * @param toHigh Upper bound of output range\n * @param precision Precision factor (e.g., 1e18)\n * @return Mapped value in the new range\n */\nfunction mapRange(\n    uint256 value,\n    uint256 fromLow,\n    uint256 fromHigh,\n    uint256 toLow,\n    uint256 toHigh,\n    uint256 precision\n) internal pure returns (uint256) {\n    if (fromLow >= fromHigh || toLow >= toHigh) return toLow;\n    if (value <= fromLow) return toLow;\n    if (value >= fromHigh) return toHigh;\n    \n    uint256 fromRange = fromHigh - fromLow;\n    uint256 toRange = toHigh - toLow;\n    \n    // Use high-precision calculation to avoid rounding errors\n    return toLow + ((value - fromLow) * toRange * precision / fromRange / precision);\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"linear-interpolation",children:"Linear Interpolation"}),"\n",(0,r.jsx)(n.p,{children:"Calculate values along a linear path between two points:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-solidity",children:"/**\n * @dev Calculate linear interpolation between two points\n * @param startValue Start value\n * @param endValue End value\n * @param startPosition Start position (0-1 scaled by precision)\n * @param endPosition End position (0-1 scaled by precision)\n * @param currentPosition Current position (0-1 scaled by precision)\n * @param precision Precision factor (e.g., 1e18)\n * @return interpolatedValue The interpolated value\n */\nfunction linearInterpolation(\n    uint256 startValue,\n    uint256 endValue,\n    uint256 startPosition,\n    uint256 endPosition,\n    uint256 currentPosition,\n    uint256 precision\n) internal pure returns (uint256 interpolatedValue) {\n    if (endPosition <= startPosition) return startValue;\n    if (currentPosition <= startPosition) return startValue;\n    if (currentPosition >= endPosition) return endValue;\n    \n    uint256 positionRange = endPosition - startPosition;\n    uint256 valueRange = endValue > startValue ? \n                        (endValue - startValue) : \n                        (startValue - endValue);\n    \n    uint256 positionRatio = ((currentPosition - startPosition) * precision) / positionRange;\n    \n    if (endValue > startValue) {\n        return startValue + ((positionRatio * valueRange) / precision);\n    } else {\n        return startValue - ((positionRatio * valueRange) / precision);\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"usage-examples",children:"Usage Examples"}),"\n",(0,r.jsx)(n.h3,{id:"governance-voting-power",children:"Governance Voting Power"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-solidity",children:'// Import the library\nimport "../math/DragonMathLib.sol";\n\ncontract GovernanceContract {\n    using DragonMathLib for uint256;\n    \n    function calculateVotingPower(uint256 tokenBalance) public pure returns (uint256) {\n        return DragonMathLib.calculateVotingPower(tokenBalance);\n    }\n    \n    function determineQuorum(uint256 totalSupply) public pure returns (uint256) {\n        // Calculate cube root of total supply for a fair quorum requirement\n        uint256 votingPower = DragonMathLib.calculateVotingPower(totalSupply);\n        // Use 10% of the voting power as quorum\n        return votingPower / 10;\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"dynamic-pricing-model",children:"Dynamic Pricing Model"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-solidity",children:'// Import the library\nimport "../math/DragonMathLib.sol";\n\ncontract DynamicPricingModel {\n    using DragonMathLib for uint256;\n    \n    uint256 private constant PRECISION = 1e18;\n    \n    // Map the utilization rate to an interest rate\n    function calculateInterestRate(uint256 utilizationRate) public pure returns (uint256) {\n        // Map 0-100% utilization to 2-20% interest\n        return DragonMathLib.mapRange(\n            utilizationRate,\n            0,\n            PRECISION,\n            2 * PRECISION / 100,  // 2%\n            20 * PRECISION / 100, // 20%\n            PRECISION\n        );\n    }\n    \n    // Calculate weighted average price\n    function calculateWeightedPrice(\n        uint256[] memory prices,\n        uint256[] memory volumes\n    ) public pure returns (uint256) {\n        return DragonMathLib.calculateWeightedAverage(prices, volumes, PRECISION);\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"gas-optimization",children:"Gas Optimization"}),"\n",(0,r.jsx)(n.p,{children:"The DragonMathLib implements several gas optimizations:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Early Returns"}),": Functions return early for edge cases like zero inputs"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Limited Iterations"}),": Newton's method implementation caps iterations at 8"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Smart Initial Guesses"}),": Uses logarithmic approximation for better starting points"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Early Exit Conditions"}),": Breaks loops when convergence is detected"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Precision Management"}),": Carefully manages multiplication/division order to maintain precision"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"security-considerations",children:"Security Considerations"}),"\n",(0,r.jsx)(n.p,{children:"When using the DragonMathLib, consider these security best practices:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Precision Handling"}),": Be consistent with precision factors across calculations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Overflow Awareness"}),": While Solidity 0.8+ has built-in overflow checks, be cautious with large numbers"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Division Safety"}),": Always check for division by zero"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Order of Operations"}),": The order of multiplication and division affects precision"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Array Validation"}),": Validate array inputs before using functions like ",(0,r.jsx)(n.code,{children:"calculateWeightedAverage"})]}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>s});var i=t(6540);const r={},a=i.createContext(r);function o(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(a.Provider,{value:n},e.children)}},9329:(e,n,t)=>{t.d(n,{A:()=>o});t(6540);var i=t(4164);const r={tabItem:"tabItem_Ymn6"};var a=t(4848);function o({children:e,hidden:n,className:t}){return(0,a.jsx)("div",{role:"tabpanel",className:(0,i.A)(r.tabItem,t),hidden:n,children:e})}}}]);