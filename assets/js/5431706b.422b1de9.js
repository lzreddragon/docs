"use strict";(self.webpackChunksonic_red_dragon_docs=self.webpackChunksonic_red_dragon_docs||[]).push([[5962],{2552:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>o,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"contracts/oracles/vrf-lib","title":"DragonVRFLib","description":"The DragonVRFLib is a utility library that provides helper functions for deploying and managing VRF (Verifiable Random Function) consumer contracts in the OmniDragon ecosystem.","source":"@site/docs/contracts/oracles/vrf-lib.md","sourceDirName":"contracts/oracles","slug":"/contracts/oracles/vrf-lib","permalink":"/contracts/oracles/vrf-lib","draft":false,"unlisted":false,"editUrl":"https://github.com/wenakita/sonicreddragon-docs/edit/main/docs/contracts/oracles/vrf-lib.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"contracts","previous":{"title":"DragonVRFIntegrator","permalink":"/contracts/oracles/vrf-integrator"},"next":{"title":"drand Network Integration","permalink":"/contracts/oracles/drand-integration"}}');var i=r(4848),t=r(8453);const o={sidebar_position:3},s="DragonVRFLib",l={},d=[{value:"Overview",id:"overview",level:2},{value:"Key Features",id:"key-features",level:2},{value:"Library Implementation",id:"library-implementation",level:2},{value:"Deployment Functions",id:"deployment-functions",level:2},{value:"Configuration Functions",id:"configuration-functions",level:2},{value:"Cross-Chain Integration",id:"cross-chain-integration",level:2},{value:"Usage Examples",id:"usage-examples",level:2},{value:"Deploying a VRF Consumer",id:"deploying-a-vrf-consumer",level:3},{value:"Configuring Cross-Chain VRF",id:"configuring-cross-chain-vrf",level:3},{value:"Security Considerations",id:"security-considerations",level:2},{value:"Upgradeability Pattern",id:"upgradeability-pattern",level:2}];function c(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"dragonvrflib",children:"DragonVRFLib"})}),"\n",(0,i.jsxs)(e.p,{children:["The ",(0,i.jsx)(e.code,{children:"DragonVRFLib"})," is a utility library that provides helper functions for deploying and managing VRF (Verifiable Random Function) consumer contracts in the OmniDragon ecosystem."]}),"\n",(0,i.jsx)(e.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(e.p,{children:"This library simplifies the deployment and configuration of VRF consumer contracts by providing standardized functions that handle common tasks:"}),"\n",(0,i.jsx)(e.mermaid,{value:'flowchart TD\n    subgraph "DragonVRFLib"\n        Deploy["Deployment Functions"]\n        Config["Configuration Functions"]\n        Proxy["Proxy Management"]\n    end\n    \n    Deploy --\x3e|"Creates"| VRFConsumerProxy["VRF Consumer Proxy"]\n    VRFConsumerProxy --\x3e|"Delegates to"| VRFConsumerImpl["VRF Consumer Implementation"]\n    \n    Config --\x3e|"Updates"| VRFConsumerProxy\n    Config --\x3e|"Configures"| Connections["Cross-Chain Connections"]\n    \n    Proxy --\x3e|"Manages"| ProxyAdmin["Proxy Admin"]\n    ProxyAdmin --\x3e|"Controls"| VRFConsumerProxy\n    \n    classDef highlight fill:#4a80d1,stroke:#333,stroke-width:2px,color:white;\n    class Deploy,Config highlight'}),"\n",(0,i.jsx)(e.h2,{id:"key-features",children:"Key Features"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Upgradeability Support"}),": Deploys VRF consumers behind transparent proxies for future upgrades"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Standardized Deployment"}),": Consistent deployment pattern for all VRF consumer contracts"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Parameter Management"}),": Structured approach to managing VRF configuration parameters"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Cross-Chain Integration"}),": Utilities for configuring cross-chain VRF connections"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"library-implementation",children:"Library Implementation"}),"\n",(0,i.jsx)(e.p,{children:"The core of DragonVRFLib is implemented as follows:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-solidity",children:'// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport "@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol";\nimport "@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol";\n\n/**\n * @title DragonVRFLib\n * @dev Library for deploying VRFConsumer contracts with upgradeability support\n */\nlibrary DragonVRFLib {\n    /**\n     * @dev Parameters for deploying a VRFConsumer contract\n     */\n    struct VRFParams {\n        address implementation;\n        address coordinator;\n        bytes32 keyHash;\n        uint64 subscriptionId;\n        uint32 callbackGasLimit;\n        uint16 requestConfirmations;\n        uint32 numWords;\n        address proxyAdmin;\n        bytes initData; // Encoded initializer data\n    }\n\n    /**\n     * @notice Deploys a VRFConsumer contract behind a TransparentUpgradeableProxy\n     * @param params The deployment parameters\n     * @param owner The owner of the deployed contract\n     * @return proxy The address of the deployed proxy contract\n     */\n    function deployVRFConsumer(\n        VRFParams memory params,\n        address owner\n    ) internal returns (address proxy) {\n        require(params.implementation != address(0), "No implementation");\n        require(params.proxyAdmin != address(0), "No proxy admin");\n        // Deploy the proxy\n        TransparentUpgradeableProxy p = new TransparentUpgradeableProxy(\n            params.implementation,\n            params.proxyAdmin,\n            params.initData\n        );\n        proxy = address(p);\n        // Optionally, transfer ownership or set up roles here\n        return proxy;\n    }\n}\n'})}),"\n",(0,i.jsx)(e.h2,{id:"deployment-functions",children:"Deployment Functions"}),"\n",(0,i.jsx)(e.p,{children:"The library provides a function to deploy VRF consumers with proxy support:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-solidity",children:'/**\n * @notice Deploys a VRFConsumer contract behind a TransparentUpgradeableProxy\n * @param params The deployment parameters\n * @param owner The owner of the deployed contract\n * @return proxy The address of the deployed proxy contract\n */\nfunction deployVRFConsumer(\n    VRFParams memory params,\n    address owner\n) internal returns (address proxy) {\n    require(params.implementation != address(0), "No implementation");\n    require(params.proxyAdmin != address(0), "No proxy admin");\n    // Deploy the proxy\n    TransparentUpgradeableProxy p = new TransparentUpgradeableProxy(\n        params.implementation,\n        params.proxyAdmin,\n        params.initData\n    );\n    proxy = address(p);\n    // Optionally, transfer ownership or set up roles here\n    return proxy;\n}\n'})}),"\n",(0,i.jsx)(e.h2,{id:"configuration-functions",children:"Configuration Functions"}),"\n",(0,i.jsx)(e.p,{children:"The library also includes functions for configuring VRF consumers after deployment:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-solidity",children:'/**\n * @notice Updates the lottery contract address in the VRFConsumer\n * @param vrfConsumer The address of the VRFConsumer contract\n * @param lotteryContract The new lottery contract address\n */\nfunction updateLotteryContract(\n    address vrfConsumer,\n    address lotteryContract\n) internal {\n    // Example: call a function on the VRFConsumer to update the lottery contract\n    // (bool success,) = vrfConsumer.call(abi.encodeWithSignature("setLotteryContract(address)", lotteryContract));\n    // require(success, "Update failed");\n}\n'})}),"\n",(0,i.jsx)(e.h2,{id:"cross-chain-integration",children:"Cross-Chain Integration"}),"\n",(0,i.jsx)(e.p,{children:"Support for cross-chain VRF integration is provided through functions that manage peer addresses:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-solidity",children:'/**\n * @notice Updates peer addresses for VRF contracts\n * @param arbReq The Arbitrum VRF requester address\n * @param sonicVRF The Sonic VRF consumer address\n */\nfunction updateVRFPeers(\n    address arbReq,\n    address sonicVRF\n) internal {\n    // Example: call a function to update peer addresses\n    // (bool success,) = arbReq.call(abi.encodeWithSignature("setPeer(address)", sonicVRF));\n    // require(success, "Update failed");\n}\n'})}),"\n",(0,i.jsx)(e.h2,{id:"usage-examples",children:"Usage Examples"}),"\n",(0,i.jsx)(e.h3,{id:"deploying-a-vrf-consumer",children:"Deploying a VRF Consumer"}),"\n",(0,i.jsx)(e.p,{children:"Here's how to use the library to deploy a VRF consumer contract:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-solidity",children:'// Import the library\nimport "../lib/dragon/DragonVRFLib.sol";\n\ncontract DragonVRFDeployer {\n    using DragonVRFLib for *;\n    \n    address public proxyAdmin;\n    address public implementation;\n    \n    constructor(address _proxyAdmin, address _implementation) {\n        proxyAdmin = _proxyAdmin;\n        implementation = _implementation;\n    }\n    \n    function deployConsumer(\n        address coordinator,\n        bytes32 keyHash,\n        uint64 subscriptionId,\n        uint32 callbackGasLimit,\n        uint16 requestConfirmations,\n        uint32 numWords,\n        address owner\n    ) external returns (address) {\n        // Encode initialization data\n        bytes memory initData = abi.encodeWithSignature(\n            "initialize(address,bytes32,uint64,uint32,uint16,uint32,address)",\n            coordinator,\n            keyHash,\n            subscriptionId,\n            callbackGasLimit,\n            requestConfirmations,\n            numWords,\n            owner\n        );\n        \n        // Set up deployment parameters\n        DragonVRFLib.VRFParams memory params = DragonVRFLib.VRFParams({\n            implementation: implementation,\n            coordinator: coordinator,\n            keyHash: keyHash,\n            subscriptionId: subscriptionId,\n            callbackGasLimit: callbackGasLimit,\n            requestConfirmations: requestConfirmations,\n            numWords: numWords,\n            proxyAdmin: proxyAdmin,\n            initData: initData\n        });\n        \n        // Deploy the consumer\n        return DragonVRFLib.deployVRFConsumer(params, owner);\n    }\n}\n'})}),"\n",(0,i.jsx)(e.h3,{id:"configuring-cross-chain-vrf",children:"Configuring Cross-Chain VRF"}),"\n",(0,i.jsx)(e.p,{children:"Here's how to configure cross-chain VRF connections:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-solidity",children:'// Import the library\nimport "../lib/dragon/DragonVRFLib.sol";\n\ncontract DragonVRFManager {\n    using DragonVRFLib for *;\n    \n    function configureCrossChainVRF(\n        address arbitrumVRF,\n        address ethereumVRF\n    ) external {\n        // Update peer addresses\n        DragonVRFLib.updateVRFPeers(arbitrumVRF, ethereumVRF);\n    }\n}\n'})}),"\n",(0,i.jsx)(e.h2,{id:"security-considerations",children:"Security Considerations"}),"\n",(0,i.jsx)(e.p,{children:"When using the DragonVRFLib, consider these security best practices:"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Proxy Admin Management"}),": Carefully manage the proxy admin address, as it has the power to upgrade the implementation"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Initialization Values"}),": Ensure initialization parameters are correct, as they cannot be easily changed after deployment"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Access Control"}),": Implement proper access control in the VRF consumer contracts"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Parameter Validation"}),": Validate all parameters before deployment to prevent issues"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Gas Limits"}),": Set appropriate callback gas limits to ensure randomness fulfillment succeeds"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"upgradeability-pattern",children:"Upgradeability Pattern"}),"\n",(0,i.jsx)(e.p,{children:"The library uses OpenZeppelin's TransparentUpgradeableProxy pattern:"}),"\n",(0,i.jsx)(e.mermaid,{value:"sequenceDiagram\n    participant Caller\n    participant Proxy as TransparentUpgradeableProxy\n    participant Implementation\n    participant Admin as ProxyAdmin\n    \n    Caller->>Proxy: function call\n    \n    alt Caller is admin\n        Proxy->>Admin: delegate admin functions\n    else Caller is not admin\n        Proxy->>Implementation: delegate call\n        Implementation->>Implementation: execute logic\n        Implementation--\x3e>Proxy: return result\n        Proxy--\x3e>Caller: return result\n    end"}),"\n",(0,i.jsx)(e.p,{children:"This pattern allows:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Separation of concerns between admin operations and contract logic"}),"\n",(0,i.jsx)(e.li,{children:"Upgrading the implementation while preserving storage"}),"\n",(0,i.jsx)(e.li,{children:"Maintaining the same address for the contract interface"}),"\n"]})]})}function p(n={}){const{wrapper:e}={...(0,t.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(c,{...n})}):c(n)}},8453:(n,e,r)=>{r.d(e,{R:()=>o,x:()=>s});var a=r(6540);const i={},t=a.createContext(i);function o(n){const e=a.useContext(t);return a.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:o(n.components),a.createElement(t.Provider,{value:e},n.children)}}}]);