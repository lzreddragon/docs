"use strict";(self.webpackChunksonic_red_dragon_docs=self.webpackChunksonic_red_dragon_docs||[]).push([[424],{1836:(n,e,s)=>{s.r(e),s.d(e,{assets:()=>d,contentTitle:()=>a,default:()=>u,frontMatter:()=>o,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"ecosystem/drand-network","title":"dRAND Network Integration","description":"OmniDragon integrates with the dRAND network to provide verifiable randomness for various operations. This integration ensures fair and transparent random number generation across all supported chains.","source":"@site/docs/ecosystem/drand-network.md","sourceDirName":"ecosystem","slug":"/ecosystem/drand-network","permalink":"/ecosystem/drand-network","draft":false,"unlisted":false,"editUrl":"https://github.com/wenakita/sonicreddragon-docs/edit/main/docs/ecosystem/drand-network.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1}}');var i=s(4848),t=s(8453);const o={sidebar_position:1},a="dRAND Network Integration",d={},l=[{value:"What is dRAND?",id:"what-is-drand",level:2},{value:"How OmniDragon Uses dRAND",id:"how-omnidragon-uses-drand",level:2},{value:"Technical Implementation",id:"technical-implementation",level:2},{value:"Randomness Request Flow",id:"randomness-request-flow",level:3},{value:"Multi-Source Aggregation",id:"multi-source-aggregation",level:3},{value:"Integration Points",id:"integration-points",level:3},{value:"Security Considerations",id:"security-considerations",level:2},{value:"Usage Examples",id:"usage-examples",level:2},{value:"Basic Randomness Request",id:"basic-randomness-request",level:3},{value:"Accessing Aggregated Randomness",id:"accessing-aggregated-randomness",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Monitoring and Maintenance",id:"monitoring-and-maintenance",level:2},{value:"Support and Resources",id:"support-and-resources",level:2}];function c(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"drand-network-integration",children:"dRAND Network Integration"})}),"\n",(0,i.jsx)(e.p,{children:"OmniDragon integrates with the dRAND network to provide verifiable randomness for various operations. This integration ensures fair and transparent random number generation across all supported chains."}),"\n",(0,i.jsx)(e.h2,{id:"what-is-drand",children:"What is dRAND?"}),"\n",(0,i.jsx)(e.p,{children:"dRAND (Distributed Random Beacon) is a public randomness service that provides cryptographically secure random numbers. It's operated by a network of independent participants and provides:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Verifiable randomness"}),"\n",(0,i.jsx)(e.li,{children:"Regular beacon rounds (every 3-30 seconds)"}),"\n",(0,i.jsx)(e.li,{children:"Cross-chain compatibility"}),"\n",(0,i.jsx)(e.li,{children:"High security guarantees through threshold cryptography"}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"how-omnidragon-uses-drand",children:"How OmniDragon Uses dRAND"}),"\n",(0,i.jsx)(e.p,{children:"Our integration with dRAND serves several purposes:"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Fair Distribution"}),": Ensuring fair token distribution and airdrops"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Game Mechanics"}),": Powering random events in games and applications"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Security"}),": Adding entropy to security-critical operations"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Cross-Chain Operations"}),": Providing consistent randomness across chains"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"technical-implementation",children:"Technical Implementation"}),"\n",(0,i.jsx)(e.p,{children:"OmniDragon implements multiple layers of randomness integration through a set of specialized contracts:"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"DragonVRFIntegrator"}),": Direct interface to the dRAND network"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"DragonVRFConsumer"}),": Base contract for consuming randomness"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"OmniDragonVRFConsumer"}),": Advanced consumer with multi-source aggregation"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"randomness-request-flow",children:"Randomness Request Flow"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Request Initiation"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-solidity",children:"function requestRandomness() external returns (uint256 requestId) {\n    requestIdCounter++;\n    uint256 requestId = requestIdCounter;\n    \n    requests[requestId] = Request({\n        fulfilled: false,\n        randomness: 0,\n        round: 0\n    });\n    \n    emit RandomnessRequested(requestId);\n    return requestId;\n}\n"})}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Callback Processing"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-solidity",children:'function fulfillRandomness(\n    uint256 _requestId, \n    uint256 _randomness,\n    uint256 _round\n) external override {\n    require(msg.sender == vrfIntegrator, "Invalid caller");\n    require(!requests[_requestId].fulfilled, "Already fulfilled");\n    \n    requests[_requestId].fulfilled = true;\n    requests[_requestId].randomness = _randomness;\n    requests[_requestId].round = _round;\n    \n    emit RandomnessFulfilled(_requestId, _randomness, _round);\n    \n    _fulfillRandomness(_requestId, _randomness);\n}\n'})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"multi-source-aggregation",children:"Multi-Source Aggregation"}),"\n",(0,i.jsx)(e.p,{children:"OmniDragon can aggregate randomness from multiple dRAND networks:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-solidity",children:'function aggregateRandomness() public {\n    require(networkIds.length > 0, "No networks configured");\n    \n    // Seed with previous value\n    uint256 randomSeed = aggregatedRandomness;\n    uint256 totalWeight = 0;\n    uint256 activeNetworks = 0;\n    \n    // Go through each network\n    for (uint256 i = 0; i < networkIds.length; i++) {\n        NetworkInfo storage network = networks[networkIds[i]];\n        \n        if (!network.active) continue;\n        \n        try IDragonVRFIntegrator(network.integrator).getLatestRandomness() returns (uint256 randomness, uint256 round) {\n            // Only use if this is new randomness\n            if (round > network.lastRound) {\n                // Apply weighted randomness\n                randomSeed = uint256(keccak256(abi.encodePacked(\n                    randomSeed, \n                    randomness, \n                    round, \n                    network.weight\n                )));\n                \n                // Update network info\n                network.lastValue = randomness;\n                network.lastRound = round;\n                network.lastUpdate = block.timestamp;\n                \n                totalWeight += network.weight;\n                activeNetworks++;\n            }\n        } catch {\n            // Skip networks that fail\n        }\n    }\n    \n    // Final aggregation with unique counter\n    if (activeNetworks > 0) {\n        aggregationCounter++;\n        aggregatedRandomness = uint256(keccak256(abi.encodePacked(\n            randomSeed, \n            block.timestamp, \n            block.difficulty, \n            totalWeight,\n            aggregationCounter\n        )));\n        \n        lastAggregationTimestamp = block.timestamp;\n        \n        emit RandomnessAggregated(block.timestamp, aggregatedRandomness);\n    }\n}\n'})}),"\n",(0,i.jsx)(e.h3,{id:"integration-points",children:"Integration Points"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Token Distribution"}),": Random selection for airdrops and rewards"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Bridge Security"}),": Random challenges for cross-chain operations"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Game Mechanics"}),": Fair random number generation for games"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Security Features"}),": Additional entropy for security measures"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"security-considerations",children:"Security Considerations"}),"\n",(0,i.jsx)(e.p,{children:"Our dRAND integration includes several security measures:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Multiple randomness sources with weighted aggregation"}),"\n",(0,i.jsx)(e.li,{children:"Verification of randomness proofs"}),"\n",(0,i.jsx)(e.li,{children:"Fallback mechanisms when networks are unavailable"}),"\n",(0,i.jsx)(e.li,{children:"Rate limiting and access control"}),"\n",(0,i.jsx)(e.li,{children:"Regular re-aggregation (every 30 seconds maximum)"}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"usage-examples",children:"Usage Examples"}),"\n",(0,i.jsx)(e.h3,{id:"basic-randomness-request",children:"Basic Randomness Request"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-solidity",children:"// Request randomness\nDragonVRFConsumer consumer = DragonVRFConsumer(consumerAddress);\nuint256 requestId = consumer.requestRandomness();\n\n// Handle the callback (override in derived contract)\nfunction _fulfillRandomness(uint256 _requestId, uint256 _randomness) internal override {\n    // Use the randomness value\n    uint256 randomNumber = _randomness % maxValue;\n    // Process the random number\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"accessing-aggregated-randomness",children:"Accessing Aggregated Randomness"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-solidity",children:"// Get the latest aggregated randomness\nOmniDragonVRFConsumer omniConsumer = OmniDragonVRFConsumer(omniConsumerAddress);\nuint256 latestRandomness = omniConsumer.aggregatedRandomness();\n\n// Force aggregation to get fresh randomness\nomniConsumer.aggregateRandomness();\nuint256 freshRandomness = omniConsumer.aggregatedRandomness();\n"})}),"\n",(0,i.jsx)(e.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsx)(e.p,{children:"When using OmniDragon's randomness system:"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:"Always verify the source of randomness"}),"\n",(0,i.jsx)(e.li,{children:"Implement proper fallback mechanisms"}),"\n",(0,i.jsx)(e.li,{children:"Use appropriate access controls"}),"\n",(0,i.jsx)(e.li,{children:"Consider gas costs when requesting randomness"}),"\n",(0,i.jsx)(e.li,{children:"Test thoroughly with different network conditions"}),"\n",(0,i.jsx)(e.li,{children:"Don't rely on a single randomness source for critical operations"}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"monitoring-and-maintenance",children:"Monitoring and Maintenance"}),"\n",(0,i.jsx)(e.p,{children:"Our system includes:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Real-time monitoring of dRAND network status"}),"\n",(0,i.jsx)(e.li,{children:"Automatic fallback to alternative randomness sources"}),"\n",(0,i.jsx)(e.li,{children:"Regular security audits"}),"\n",(0,i.jsx)(e.li,{children:"Performance optimization"}),"\n",(0,i.jsx)(e.li,{children:"Cross-chain consistency checks"}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"support-and-resources",children:"Support and Resources"}),"\n",(0,i.jsx)(e.p,{children:"For help with dRAND integration:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"https://drand.love",children:"dRAND Documentation"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"https://github.com/wenakita/sonicreddragon",children:"OmniDragon GitHub"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"https://discord.gg/",children:"Discord Support"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"mailto:support@sonicreddragon.io",children:"Technical Support"})}),"\n"]})]})}function u(n={}){const{wrapper:e}={...(0,t.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(c,{...n})}):c(n)}},8453:(n,e,s)=>{s.d(e,{R:()=>o,x:()=>a});var r=s(6540);const i={},t=r.createContext(i);function o(n){const e=r.useContext(t);return r.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:o(n.components),r.createElement(t.Provider,{value:e},n.children)}}}]);