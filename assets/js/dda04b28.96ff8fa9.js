"use strict";(self.webpackChunksonic_red_dragon_docs=self.webpackChunksonic_red_dragon_docs||[]).push([[9300],{487:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"contracts/math/overview","title":"Mathematical Framework","description":"Introduction","source":"@site/docs/contracts/math/overview.md","sourceDirName":"contracts/math","slug":"/contracts/math/overview","permalink":"/contracts/math/overview","draft":false,"unlisted":false,"editUrl":"https://github.com/wenakita/sonicreddragon-docs/edit/main/docs/contracts/math/overview.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"contracts","previous":{"title":"drand Network Integration","permalink":"/contracts/oracles/drand-integration"},"next":{"title":"DragonMathLib","permalink":"/contracts/math/dragon-math-lib"}}');var r=n(4848),a=n(8453);const o={sidebar_position:1},s="Mathematical Framework",l={},c=[{value:"Introduction",id:"introduction",level:2},{value:"System Architecture",id:"system-architecture",level:2},{value:"Core Libraries",id:"core-libraries",level:3},{value:"Domain-Specific Libraries",id:"domain-specific-libraries",level:3},{value:"Mathematical Principles",id:"mathematical-principles",level:2},{value:"1. Fixed-Point Decimal Arithmetic",id:"1-fixed-point-decimal-arithmetic",level:3},{value:"2. Cube Root Distribution (Wyoming Rule)",id:"2-cube-root-distribution-wyoming-rule",level:3},{value:"3. Iterative Approximation",id:"3-iterative-approximation",level:3},{value:"4. Herm\xe8s Formula",id:"4-herm\xe8s-formula",level:3},{value:"Key Components",id:"key-components",level:2},{value:"1. DragonMathLib",id:"1-dragonmathlib",level:3},{value:"2. HermesMath",id:"2-hermesmath",level:3},{value:"3. DragonDateTimeLib",id:"3-dragondatetimelib",level:3},{value:"4. ve69LPMath",id:"4-ve69lpmath",level:3},{value:"5. VotingPowerCalculator",id:"5-votingpowercalculator",level:3},{value:"6. DragonAdaptiveFeeManager",id:"6-dragonadaptivefeemanager",level:3},{value:"7. HermesMathIntegration",id:"7-hermesmathintegration",level:3},{value:"8. MarketConditionOracle",id:"8-marketconditionoracle",level:3},{value:"Integration Examples",id:"integration-examples",level:2},{value:"Using DragonMathLib for Voting Power",id:"using-dragonmathlib-for-voting-power",level:3},{value:"Using HermesMath for Jackpot Distribution",id:"using-hermesmath-for-jackpot-distribution",level:3},{value:"Security Considerations",id:"security-considerations",level:2}];function d(e){const i={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(i.header,{children:(0,r.jsx)(i.h1,{id:"mathematical-framework",children:"Mathematical Framework"})}),"\n",(0,r.jsx)(i.h2,{id:"introduction",children:"Introduction"}),"\n",(0,r.jsx)(i.p,{children:"The OmniDragon protocol relies on sophisticated mathematical algorithms to power its core features, ranging from equitable governance voting to dynamic jackpot distribution. These mathematical libraries represent a significant innovation in on-chain computation, providing gas-efficient implementations of complex algorithms that would otherwise be prohibitively expensive to execute."}),"\n",(0,r.jsx)(i.p,{children:"Our mathematical framework is organized into modular libraries that address different aspects of the protocol:"}),"\n",(0,r.jsx)(i.mermaid,{value:'flowchart TD\n    subgraph "Protocol Core"\n        CoreMath["Core Mathematics"]\n        DistributionSystem["Distribution System"]\n        TimeCalculations["Time Calculations"]\n    end\n    \n    subgraph "Domain Applications"\n        Governance["Governance"]\n        Jackpot["Jackpot System"]\n        Market["Market Operations"]\n        Tokenomics["Token Economics"]\n    end\n    \n    CoreMath --\x3e|"Supports"| DistributionSystem\n    CoreMath --\x3e|"Supports"| TimeCalculations\n    \n    DistributionSystem --\x3e|"Powers"| Jackpot\n    CoreMath --\x3e|"Enables"| Governance\n    TimeCalculations --\x3e|"Schedules"| Jackpot\n    TimeCalculations --\x3e|"Synchronizes"| Market\n    DistributionSystem --\x3e|"Optimizes"| Tokenomics\n    \n    classDef highlight fill:#4a80d1,stroke:#333,stroke-width:2px,color:white;\n    class CoreMath,DistributionSystem highlight'}),"\n",(0,r.jsx)(i.h2,{id:"system-architecture",children:"System Architecture"}),"\n",(0,r.jsx)(i.p,{children:"The mathematical framework consists of specialized libraries that work together to solve complex problems:"}),"\n",(0,r.jsx)(i.h3,{id:"core-libraries",children:"Core Libraries"}),"\n",(0,r.jsxs)(i.table,{children:[(0,r.jsx)(i.thead,{children:(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.th,{children:"Library"}),(0,r.jsx)(i.th,{children:"Purpose"}),(0,r.jsx)(i.th,{children:"Key Features"})]})}),(0,r.jsxs)(i.tbody,{children:[(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:(0,r.jsx)(i.a,{href:"./dragon-math-lib",children:(0,r.jsx)(i.code,{children:"DragonMathLib"})})}),(0,r.jsx)(i.td,{children:"Fundamental mathematical operations"}),(0,r.jsx)(i.td,{children:"Cube root, voting power, weighted averages"})]}),(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:(0,r.jsx)(i.a,{href:"./hermes-math",children:(0,r.jsx)(i.code,{children:"HermesMath"})})}),(0,r.jsx)(i.td,{children:"Jackpot distribution mathematics"}),(0,r.jsx)(i.td,{children:"Dynamic prize allocation, win probability"})]}),(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:(0,r.jsx)(i.a,{href:"./date-time-lib",children:(0,r.jsx)(i.code,{children:"DragonDateTimeLib"})})}),(0,r.jsx)(i.td,{children:"Time-based calculations"}),(0,r.jsx)(i.td,{children:"Epoch conversion, duration calculations"})]})]})]}),"\n",(0,r.jsx)(i.h3,{id:"domain-specific-libraries",children:"Domain-Specific Libraries"}),"\n",(0,r.jsxs)(i.table,{children:[(0,r.jsx)(i.thead,{children:(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.th,{children:"Library"}),(0,r.jsx)(i.th,{children:"Purpose"}),(0,r.jsx)(i.th,{children:"Key Features"})]})}),(0,r.jsxs)(i.tbody,{children:[(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:(0,r.jsx)(i.a,{href:"./ve69lp-math",children:(0,r.jsx)(i.code,{children:"ve69LPMath"})})}),(0,r.jsx)(i.td,{children:"Vote-escrowed LP calculations"}),(0,r.jsx)(i.td,{children:"Lock duration, voting power decay"})]}),(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:(0,r.jsx)(i.a,{href:"./voting-power",children:(0,r.jsx)(i.code,{children:"VotingPowerCalculator"})})}),(0,r.jsx)(i.td,{children:"Governance weighting"}),(0,r.jsx)(i.td,{children:"Equitable delegation, proposal thresholds"})]}),(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:(0,r.jsx)(i.a,{href:"./adaptive-fee",children:(0,r.jsx)(i.code,{children:"DragonAdaptiveFeeManager"})})}),(0,r.jsx)(i.td,{children:"Dynamic fee adjustment"}),(0,r.jsx)(i.td,{children:"Market-responsive fee scaling"})]}),(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:(0,r.jsx)(i.a,{href:"./hermes-integration",children:(0,r.jsx)(i.code,{children:"HermesMathIntegration"})})}),(0,r.jsx)(i.td,{children:"Application layer"}),(0,r.jsx)(i.td,{children:"Contract interfaces for formula application"})]}),(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:(0,r.jsx)(i.a,{href:"./market-oracle",children:(0,r.jsx)(i.code,{children:"MarketConditionOracle"})})}),(0,r.jsx)(i.td,{children:"Market analytics"}),(0,r.jsx)(i.td,{children:"Price impact, volatility measurements"})]})]})]}),"\n",(0,r.jsx)(i.h2,{id:"mathematical-principles",children:"Mathematical Principles"}),"\n",(0,r.jsx)(i.p,{children:"Our framework is built on several key mathematical principles:"}),"\n",(0,r.jsx)(i.h3,{id:"1-fixed-point-decimal-arithmetic",children:"1. Fixed-Point Decimal Arithmetic"}),"\n",(0,r.jsxs)(i.p,{children:["All calculations use fixed-point decimal math to handle fractional values on EVM chains, typically with 18 decimal places of precision (",(0,r.jsx)(i.code,{children:"1e18"}),"). This approach avoids the need for floating-point operations while maintaining high precision."]}),"\n",(0,r.jsx)(i.h3,{id:"2-cube-root-distribution-wyoming-rule",children:"2. Cube Root Distribution (Wyoming Rule)"}),"\n",(0,r.jsx)(i.p,{children:"The governance system uses cube root normalization based on the political science concept of the Wyoming Rule, which creates more equitable voting power distribution. This means that as a user's token holdings increase, their voting power increases at a diminishing rate, preventing excessive influence from large holders while still rewarding greater stake."}),"\n",(0,r.jsx)(i.h3,{id:"3-iterative-approximation",children:"3. Iterative Approximation"}),"\n",(0,r.jsx)(i.p,{children:"Complex operations like cube roots are calculated using iterative methods such as Newton's method, which converges rapidly while minimizing gas usage through early exit conditions and smart initial guesses."}),"\n",(0,r.jsx)(i.h3,{id:"4-herm\xe8s-formula",children:"4. Herm\xe8s Formula"}),"\n",(0,r.jsx)(i.p,{children:"The proprietary Herm\xe8s formula for jackpot distribution uses a specialized mathematical model that balances jackpot growth with win frequency. This creates an optimal player experience while ensuring the sustainability of the protocol."}),"\n",(0,r.jsx)(i.h2,{id:"key-components",children:"Key Components"}),"\n",(0,r.jsx)(i.p,{children:"The mathematical foundation of the OmniDragon ecosystem consists of several specialized libraries:"}),"\n",(0,r.jsx)(i.h3,{id:"1-dragonmathlib",children:"1. DragonMathLib"}),"\n",(0,r.jsx)(i.p,{children:"Core mathematical utilities used throughout the protocol:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Cube root approximation using Newton's method"}),"\n",(0,r.jsx)(i.li,{children:"Voting power calculation with cube root normalization"}),"\n",(0,r.jsx)(i.li,{children:"Percentage calculations with precision control"}),"\n",(0,r.jsx)(i.li,{children:"Boost application with precise math"}),"\n",(0,r.jsx)(i.li,{children:"Weighted average calculations"}),"\n",(0,r.jsx)(i.li,{children:"Range mapping and linear interpolation"}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"2-hermesmath",children:"2. HermesMath"}),"\n",(0,r.jsx)(i.p,{children:"Implementation of the proprietary Herm\xe8s formula for dynamic jackpot distribution:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Sophisticated distribution algorithm using high-order mathematics"}),"\n",(0,r.jsx)(i.li,{children:"Components approximation for gas optimization"}),"\n",(0,r.jsx)(i.li,{children:"Fixed-point decimal arithmetic for high precision"}),"\n",(0,r.jsx)(i.li,{children:"Customizable governance parameters"}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"3-dragondatetimelib",children:"3. DragonDateTimeLib"}),"\n",(0,r.jsx)(i.p,{children:"Date and time manipulation library:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Timestamp to date/time conversion"}),"\n",(0,r.jsx)(i.li,{children:"Duration calculations"}),"\n",(0,r.jsx)(i.li,{children:"Time-based scheduling support"}),"\n",(0,r.jsx)(i.li,{children:"Cross-chain time synchronization"}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"4-ve69lpmath",children:"4. ve69LPMath"}),"\n",(0,r.jsx)(i.p,{children:"Mathematical functions for the ve69LP vote-escrowed token system:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Locked token voting power calculation"}),"\n",(0,r.jsx)(i.li,{children:"Time-decay math for voting power"}),"\n",(0,r.jsx)(i.li,{children:"Boost calculation based on lock duration"}),"\n",(0,r.jsx)(i.li,{children:"Voting weight determination"}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"5-votingpowercalculator",children:"5. VotingPowerCalculator"}),"\n",(0,r.jsx)(i.p,{children:"Specialized math for governance voting:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Cube root normalization for equitable governance"}),"\n",(0,r.jsx)(i.li,{children:"Delegation math for combined voting power"}),"\n",(0,r.jsx)(i.li,{children:"Proposal threshold calculations"}),"\n",(0,r.jsx)(i.li,{children:"Quorum determination"}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"6-dragonadaptivefeemanager",children:"6. DragonAdaptiveFeeManager"}),"\n",(0,r.jsx)(i.p,{children:"Dynamic fee calculation system:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Market-responsive fee adjustments"}),"\n",(0,r.jsx)(i.li,{children:"Volume-based fee scaling"}),"\n",(0,r.jsx)(i.li,{children:"Protocol performance optimization"}),"\n",(0,r.jsx)(i.li,{children:"Cross-chain fee normalization"}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"7-hermesmathintegration",children:"7. HermesMathIntegration"}),"\n",(0,r.jsx)(i.p,{children:"Application layer integrating the Herm\xe8s formula:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Contract interfaces for jackpot distribution"}),"\n",(0,r.jsx)(i.li,{children:"Parameter management for formula adjustments"}),"\n",(0,r.jsx)(i.li,{children:"Integration with jackpot distribution system"}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"8-marketconditionoracle",children:"8. MarketConditionOracle"}),"\n",(0,r.jsx)(i.p,{children:"Market analytics and condition assessment:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Price impact calculations"}),"\n",(0,r.jsx)(i.li,{children:"Volatility measurements"}),"\n",(0,r.jsx)(i.li,{children:"Liquidity depth analysis"}),"\n",(0,r.jsx)(i.li,{children:"Automated market maker optimization"}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"integration-examples",children:"Integration Examples"}),"\n",(0,r.jsx)(i.h3,{id:"using-dragonmathlib-for-voting-power",children:"Using DragonMathLib for Voting Power"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-solidity",children:'// Import the library\nimport "../math/DragonMathLib.sol";\n\ncontract GovernanceExample {\n    using DragonMathLib for uint256;\n    \n    // Constants\n    uint256 private constant PRECISION = 1e18;\n    \n    function calculateVote(uint256 tokenAmount) external pure returns (uint256) {\n        // Use cube root for more equitable voting power\n        return DragonMathLib.calculateVotingPower(tokenAmount);\n    }\n}\n'})}),"\n",(0,r.jsx)(i.h3,{id:"using-hermesmath-for-jackpot-distribution",children:"Using HermesMath for Jackpot Distribution"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-solidity",children:'// Import the library\nimport "../math/HermesMath.sol";\n\ncontract JackpotExample {\n    using HermesMath for uint256;\n    \n    // Governance parameters\n    uint256 public d = 3 * 1e18; // Protocol constant D\n    uint256 public n = 2 * 1e18; // Protocol constant N\n    \n    function calculatePrize(uint256 jackpotSize) external view returns (uint256) {\n        // Calculate optimal prize using Herm\xe8s formula\n        return HermesMath.calculateHermesValue(jackpotSize, d, n);\n    }\n}\n'})}),"\n",(0,r.jsx)(i.h2,{id:"security-considerations",children:"Security Considerations"}),"\n",(0,r.jsx)(i.p,{children:"The math libraries implement several security measures:"}),"\n",(0,r.jsxs)(i.ol,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Overflow Protection"}),": Using Solidity 0.8+ built-in overflow checks"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Division Safety"}),": Checks for division by zero in all calculations"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Precision Management"}),": Careful handling of precision to avoid rounding errors"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Gas Optimization"}),": Iterative approximations with early exit conditions"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Parameter Bounds"}),": Enforcing safe ranges for input parameters"]}),"\n"]})]})}function h(e={}){const{wrapper:i}={...(0,a.R)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>o,x:()=>s});var t=n(6540);const r={},a=t.createContext(r);function o(e){const i=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function s(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),t.createElement(a.Provider,{value:i},e.children)}}}]);