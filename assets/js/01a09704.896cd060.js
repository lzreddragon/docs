"use strict";(self.webpackChunksonic_red_dragon_docs=self.webpackChunksonic_red_dragon_docs||[]).push([[4669],{282:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>i,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"concepts/randomness","title":"Randomness System","description":"The OmniDragon protocol leverages multiple sources of verifiable randomness to power its jackpot system and other applications requiring secure randomness.","source":"@site/docs/concepts/randomness.md","sourceDirName":"concepts","slug":"/concepts/randomness","permalink":"/concepts/randomness","draft":false,"unlisted":false,"editUrl":"https://github.com/wenakita/sonicreddragon-docs/edit/main/docs/concepts/randomness.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Randomness System","sidebar_position":3},"sidebar":"concepts","previous":{"title":"Cross-Chain Architecture","permalink":"/concepts/cross-chain"},"next":{"title":"Jackpot System","permalink":"/concepts/jackpot"}}');var o=s(4848),t=s(8453);const i={title:"Randomness System",sidebar_position:3},a="OmniDragon Randomness System",c={},l=[{value:"System Overview",id:"system-overview",level:2},{value:"Randomness Request Flow",id:"randomness-request-flow",level:2},{value:"Multi-Chain Randomness Architecture",id:"multi-chain-randomness-architecture",level:2},{value:"Security Model",id:"security-model",level:2},{value:"Implementation Components",id:"implementation-components",level:2}];function d(e){const n={h1:"h1",h2:"h2",header:"header",mermaid:"mermaid",p:"p",...(0,t.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"omnidragon-randomness-system",children:"OmniDragon Randomness System"})}),"\n",(0,o.jsx)(n.p,{children:"The OmniDragon protocol leverages multiple sources of verifiable randomness to power its jackpot system and other applications requiring secure randomness."}),"\n",(0,o.jsx)(n.h2,{id:"system-overview",children:"System Overview"}),"\n",(0,o.jsx)(n.p,{children:"The following diagram illustrates the high-level architecture of our randomness system:"}),"\n",(0,o.jsx)(n.mermaid,{value:'flowchart TB\n    %% Define the layers with clear visual hierarchy\n    subgraph External ["External Randomness Sources"]\n        direction LR\n        DRAND["dRAND Network"]:::source\n        CHAIN["Chainlink VRF"]:::source\n        ARB["Arbitrum VRF"]:::source\n    end\n    \n    subgraph Verification ["On-Chain Verification Layer"]\n        direction LR\n        DI["dRAND Integrator"]:::verify\n        CI["Chainlink Integrator"]:::verify\n        AI["Arbitrum Integrator"]:::verify\n    end\n    \n    subgraph Core ["Core Aggregation Layer"]\n        direction TB\n        VC["VRF Consumer"]:::core\n        RB["Randomness Buffer"]:::core\n        WC["Weighted Combiner"]:::core\n    end\n    \n    subgraph Applications ["Consumer Applications"]\n        direction LR\n        JP["Jackpot System"]:::app\n        GAME["Games"]:::app\n        GOV["Governance"]:::app\n    end\n    \n    %% Connect the components\n    DRAND --\x3e DI\n    CHAIN --\x3e CI\n    ARB --\x3e AI\n    \n    DI --\x3e VC\n    CI --\x3e VC\n    AI --\x3e VC\n    \n    VC --\x3e RB\n    RB --\x3e WC\n    \n    WC --\x3e JP\n    WC --\x3e GAME\n    WC --\x3e GOV\n    \n    %% Apply styling\n    classDef source fill:#f8f9fa,stroke:#6c757d,color:#343a40\n    classDef verify fill:#e9ecef,stroke:#495057,color:#212529\n    classDef core fill:#e7f5ff,stroke:#339af0,color:#1864ab\n    classDef app fill:#ebfbee,stroke:#37b24d,color:#2b8a3e\n    \n    %% Style subgraphs\n    style External fill:#f8f9fa,stroke:#dee2e6,color:#495057\n    style Verification fill:#e9ecef,stroke:#ced4da,color:#495057\n    style Core fill:#e7f5ff,stroke:#74c0fc,color:#1864ab\n    style Applications fill:#ebfbee,stroke:#8ce99a,color:#2b8a3e'}),"\n",(0,o.jsx)(n.h2,{id:"randomness-request-flow",children:"Randomness Request Flow"}),"\n",(0,o.jsx)(n.p,{children:"The sequence diagram below shows how randomness is requested and fulfilled:"}),"\n",(0,o.jsx)(n.mermaid,{value:"sequenceDiagram\n    participant App as Consumer App\n    participant VRF as VRF Consumer\n    participant Sources as Randomness Sources\n    participant Buffer as Randomness Buffer\n    \n    rect rgb(240, 244, 248)\n    note over App: Initiates request\n    end\n    \n    App->>+VRF: requestRandomness()\n    VRF->>VRF: Generate request ID\n    VRF--\x3e>App: Return request ID\n    \n    rect rgb(235, 241, 245)\n    note over VRF,Sources: External verification\n    end\n    \n    par Request from multiple sources\n        VRF->>+Sources: Request from dRAND\n        Sources--\x3e>-VRF: Return dRAND proof\n        \n        VRF->>+Sources: Request from Chainlink\n        Sources--\x3e>-VRF: Return Chainlink proof\n        \n        VRF->>+Sources: Request from Arbitrum\n        Sources--\x3e>-VRF: Return Arbitrum proof\n    end\n    \n    rect rgb(231, 245, 255)\n    note over VRF,Buffer: Aggregation\n    end\n    \n    VRF->>+Buffer: Store verified randomness\n    Buffer--\x3e>-VRF: Confirm storage\n    Buffer->>Buffer: Combine randomness\n    Buffer->>+App: fulfillRandomness(requestId, result)\n    \n    rect rgb(235, 251, 238)\n    note over App: Process result\n    end\n    \n    App->>App: Process randomness\n    App--\x3e>-Buffer: Acknowledge receipt"}),"\n",(0,o.jsx)(n.h2,{id:"multi-chain-randomness-architecture",children:"Multi-Chain Randomness Architecture"}),"\n",(0,o.jsx)(n.p,{children:"Our system works across multiple chains with secure cross-chain verification:"}),"\n",(0,o.jsx)(n.mermaid,{value:'flowchart LR\n    %% Define chain-specific components\n    subgraph Ethereum ["Ethereum"]\n        direction TB\n        ETH_DRAND["dRAND Verifier"]:::eth\n        ETH_CHAIN["Chainlink VRF"]:::eth\n        ETH_CONSUMER["ETH VRF Consumer"]:::eth\n    end\n    \n    subgraph Arbitrum ["Arbitrum"]\n        direction TB\n        ARB_VRF["Arbitrum VRF"]:::arb\n        ARB_CONSUMER["ARB VRF Consumer"]:::arb\n    end\n    \n    subgraph Optimism ["Optimism"]\n        direction TB\n        OPT_CONSUMER["OPT VRF Consumer"]:::opt\n    end\n    \n    subgraph LayerZero ["Cross-Chain Messaging"]\n        LZ["LayerZero"]:::lz\n    end\n    \n    %% Connect components\n    ETH_DRAND --\x3e ETH_CONSUMER\n    ETH_CHAIN --\x3e ETH_CONSUMER\n    ARB_VRF --\x3e ARB_CONSUMER\n    \n    ETH_CONSUMER <--\x3e LZ\n    ARB_CONSUMER <--\x3e LZ\n    OPT_CONSUMER <--\x3e LZ\n    \n    LZ --\x3e ETH_CONSUMER\n    LZ --\x3e ARB_CONSUMER\n    LZ --\x3e OPT_CONSUMER\n    \n    %% Apply styling\n    classDef eth fill:#eceff1,stroke:#546e7a,color:#263238\n    classDef arb fill:#ede7f6,stroke:#7e57c2,color:#311b92\n    classDef opt fill:#e3f2fd,stroke:#42a5f5,color:#0d47a1\n    classDef lz fill:#e8f5e9,stroke:#66bb6a,color:#1b5e20\n    \n    %% Style subgraphs\n    style Ethereum fill:#eceff1,stroke:#cfd8dc,color:#263238\n    style Arbitrum fill:#ede7f6,stroke:#d1c4e9,color:#311b92\n    style Optimism fill:#e3f2fd,stroke:#bbdefb,color:#0d47a1\n    style LayerZero fill:#e8f5e9,stroke:#c8e6c9,color:#1b5e20'}),"\n",(0,o.jsx)(n.h2,{id:"security-model",children:"Security Model"}),"\n",(0,o.jsx)(n.p,{children:"The diagram below illustrates our multi-layered security approach:"}),"\n",(0,o.jsx)(n.mermaid,{value:'flowchart TB\n    %% Security layers\n    subgraph InputSecurity ["Input Security"]\n        direction LR\n        MULTI["Multiple Sources"]:::sec1\n        THRESH["Threshold Security"]:::sec1\n        COMMIT["Commit-Reveal"]:::sec1\n    end\n    \n    subgraph VerificationSecurity ["Verification Security"]\n        direction LR\n        SIG["Signature Verification"]:::sec2\n        HASH["Hash Verification"]:::sec2\n        PROOF["Zero-Knowledge Proofs"]:::sec2\n    end\n    \n    subgraph OutputSecurity ["Output Security"]\n        direction LR\n        BUFFER["Randomness Buffer"]:::sec3\n        COMBINE["Weighted Combination"]:::sec3\n        DELAY["Time-Delayed Release"]:::sec3\n    end\n    \n    %% Connect security layers\n    InputSecurity --\x3e VerificationSecurity\n    VerificationSecurity --\x3e OutputSecurity\n    \n    %% Apply styling\n    classDef sec1 fill:#ffebee,stroke:#ef5350,color:#b71c1c\n    classDef sec2 fill:#e8eaf6,stroke:#7986cb,color:#1a237e\n    classDef sec3 fill:#e0f2f1,stroke:#4db6ac,color:#004d40\n    \n    %% Style subgraphs\n    style InputSecurity fill:#ffebee,stroke:#ffcdd2,color:#b71c1c\n    style VerificationSecurity fill:#e8eaf6,stroke:#c5cae9,color:#1a237e\n    style OutputSecurity fill:#e0f2f1,stroke:#b2dfdb,color:#004d40'}),"\n",(0,o.jsx)(n.h2,{id:"implementation-components",children:"Implementation Components"}),"\n",(0,o.jsx)(n.p,{children:"The following class diagram shows the main components of our randomness system:"}),"\n",(0,o.jsx)(n.mermaid,{value:"classDiagram\n    %% Define main classes\n    class IRandomnessProvider {\n        <<interface>>\n        +requestRandomness(bytes32 seed) bytes32\n        +verifyRandomness(bytes proof) bool\n    }\n    \n    class DragonVRFConsumer {\n        -mapping providers\n        -mapping requests\n        -uint256 threshold\n        +addProvider(address provider)\n        +removeProvider(address provider)\n        +requestRandomness() bytes32\n        +fulfillRandomness(bytes32 requestId, uint256 randomness)\n    }\n    \n    class RandomnessBuffer {\n        -mapping values\n        -uint256 capacity\n        +addRandomness(uint256 value)\n        +getRandomness() uint256\n        +getRandomInRange(uint256 min, uint256 max) uint256\n    }\n    \n    class dRANDIntegrator {\n        -bytes publicKey\n        +verifyRandomness(bytes signature, bytes message) bool\n        +fetchLatestRandomness() bytes32\n    }\n    \n    class ChainlinkVRFIntegrator {\n        -address coordinator\n        -bytes32 keyHash\n        +requestRandomness() bytes32\n        +fulfillRandomWords(bytes32 requestId, uint256[] randomWords)\n    }\n    \n    %% Define relationships\n    IRandomnessProvider <|-- dRANDIntegrator\n    IRandomnessProvider <|-- ChainlinkVRFIntegrator\n    DragonVRFConsumer --\x3e IRandomnessProvider\n    DragonVRFConsumer --\x3e RandomnessBuffer\n    \n    %% Apply styling\n    classDef interface fill:#e3f2fd,stroke:#2196f3,color:#0d47a1\n    classDef consumer fill:#f3e5f5,stroke:#9c27b0,color:#4a148c\n    classDef provider fill:#e8f5e9,stroke:#4caf50,color:#1b5e20\n    classDef utility fill:#fff3e0,stroke:#ff9800,color:#e65100\n    \n    class IRandomnessProvider interface\n    class DragonVRFConsumer consumer\n    class RandomnessBuffer utility\n    class dRANDIntegrator provider\n    class ChainlinkVRFIntegrator provider"}),"\n",(0,o.jsx)(n.p,{children:"By integrating multiple sources of randomness and utilizing a secure aggregation mechanism, OmniDragon achieves a highly secure and reliable source of randomness that is resistant to manipulation and single points of failure."})]})}function u(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>i,x:()=>a});var r=s(6540);const o={},t=r.createContext(o);function i(e){const n=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);