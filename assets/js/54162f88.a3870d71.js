"use strict";(self.webpackChunksonic_red_dragon_docs=self.webpackChunksonic_red_dragon_docs||[]).push([[469],{3957:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>l,frontMatter:()=>i,metadata:()=>t,toc:()=>u});const t=JSON.parse('{"id":"contracts/oracles/vrf-consumer","title":"OmniDragonVRFConsumer","description":"The OmniDragonVRFConsumer is a sophisticated randomness aggregator contract that combines multiple independent randomness sources for enhanced security and reliability.","source":"@site/docs/contracts/oracles/vrf-consumer.md","sourceDirName":"contracts/oracles","slug":"/contracts/oracles/vrf-consumer","permalink":"/contracts/oracles/vrf-consumer","draft":false,"unlisted":false,"editUrl":"https://github.com/wenakita/sonicreddragon-docs/edit/main/docs/contracts/oracles/vrf-consumer.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"contracts","previous":{"title":"Swap-Based Jackpot Trigger System","permalink":"/contracts/jackpot/triggers"},"next":{"title":"DragonVRFIntegrator","permalink":"/contracts/oracles/vrf-integrator"}}');var s=r(4848),o=r(8453);const i={sidebar_position:1},a="OmniDragonVRFConsumer",d={},u=[{value:"Overview",id:"overview",level:2},{value:"Key Features",id:"key-features",level:2},{value:"Contract Implementation",id:"contract-implementation",level:2},{value:"Network Management",id:"network-management",level:2},{value:"Randomness Aggregation",id:"randomness-aggregation",level:2},{value:"Consumer Interface",id:"consumer-interface",level:2},{value:"Fulfillment Logic",id:"fulfillment-logic",level:2},{value:"Security Features",id:"security-features",level:2},{value:"Events",id:"events",level:2},{value:"Consumer Integration",id:"consumer-integration",level:2},{value:"Usage Example",id:"usage-example",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"omnidragonvrfconsumer",children:"OmniDragonVRFConsumer"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"OmniDragonVRFConsumer"})," is a sophisticated randomness aggregator contract that combines multiple independent randomness sources for enhanced security and reliability."]}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(n.p,{children:"This contract serves as the central hub of the OmniDragon randomness system, connecting to multiple randomness sources and providing a unified interface for consumer applications:"}),"\n",(0,s.jsx)(n.mermaid,{value:'flowchart TB\n    subgraph "External Sources"\n        s1["dRAND Network"]\n        s2["Chainlink VRF"]\n        s3["Arbitrum VRF"]\n        s4["EVMnet"]\n        s5["Quicknet"]\n    end\n    \n    subgraph "Integrators"\n        i1["dRAND Integrator"]\n        i2["Chainlink Integrator"]\n        i3["Arbitrum Integrator"]\n        i4["EVMnet Integrator"]\n        i5["Quicknet Integrator"]\n    end\n    \n    subgraph "OmniDragonVRFConsumer"\n        Buffer["Randomness Buffers"]\n        Aggregator["Aggregation Logic"]\n        Security["Security Controls"]\n        Interface["Consumer Interface"]\n    end\n    \n    subgraph "Consumer Applications"\n        c1["Jackpot System"]\n        c2["Games"]\n        c3["Governance"]\n    end\n    \n    s1 --\x3e i1\n    s2 --\x3e i2\n    s3 --\x3e i3\n    s4 --\x3e i4\n    s5 --\x3e i5\n    \n    i1 --\x3e Buffer\n    i2 --\x3e Buffer\n    i3 --\x3e Buffer\n    i4 --\x3e Buffer\n    i5 --\x3e Buffer\n    \n    Buffer --\x3e Aggregator\n    Aggregator --\x3e Interface\n    Security --\x3e Interface\n    \n    Interface --\x3e c1\n    Interface --\x3e c2\n    Interface --\x3e c3\n    \n    class Aggregator highlight'}),"\n",(0,s.jsx)(n.h2,{id:"key-features",children:"Key Features"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Multi-Source Aggregation"}),": Combines randomness from multiple independent sources"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Weighted Combination"}),": Assigns configurable weights to each source"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Randomness Buffering"}),": Maintains buffers of recent values for enhanced unpredictability"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Fault Tolerance"}),": Continues functioning even if some sources are unavailable"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Access Controls"}),": Restricts randomness requests to authorized consumers"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Request/Response Pattern"}),": Uses an asynchronous request/response pattern"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"contract-implementation",children:"Contract Implementation"}),"\n",(0,s.jsx)(n.p,{children:"The core functionality of the OmniDragonVRFConsumer is implemented as follows:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"// Network tracking\nstruct NetworkInfo {\n    address integrator;\n    bool active;\n    uint256 weight;\n    uint256 lastUpdate;\n    uint256 lastValue;\n    uint256 lastRound;\n}\n\n// Network storage\nmapping(bytes32 => NetworkInfo) public networks;\nbytes32[] public networkIds;\n\n// Randomness state\nuint256 public aggregatedRandomness;\nuint256 public lastAggregationTimestamp;\nuint256 public aggregationCounter;\n\n// Consumer tracking\nmapping(address => bool) public authorizedConsumers;\n"})}),"\n",(0,s.jsx)(n.h2,{id:"network-management",children:"Network Management"}),"\n",(0,s.jsx)(n.p,{children:"The contract allows adding, updating, and removing randomness sources:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:'/**\n * @dev Add a new drand network\n * @param _networkId The unique identifier for this network\n * @param _integrator The integrator contract address\n * @param _weight The weight to give this network in aggregation\n */\nfunction addNetwork(bytes32 _networkId, address _integrator, uint256 _weight) external onlyOwner {\n    require(_integrator != address(0), "Invalid integrator address");\n    require(networks[_networkId].integrator == address(0), "Network already exists");\n    \n    networks[_networkId] = NetworkInfo({\n        integrator: _integrator,\n        active: true,\n        weight: _weight,\n        lastUpdate: 0,\n        lastValue: 0,\n        lastRound: 0\n    });\n    \n    networkIds.push(_networkId);\n    \n    emit NetworkAdded(_networkId, _integrator, _weight);\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"randomness-aggregation",children:"Randomness Aggregation"}),"\n",(0,s.jsx)(n.p,{children:"The core aggregation logic combines values from multiple sources:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:'/**\n * @dev Aggregate randomness from all active networks\n */\nfunction aggregateRandomness() public {\n    require(networkIds.length > 0, "No networks configured");\n    \n    // Seed with previous value\n    uint256 randomSeed = aggregatedRandomness;\n    uint256 totalWeight = 0;\n    uint256 activeNetworks = 0;\n    \n    // Go through each network\n    for (uint256 i = 0; i < networkIds.length; i++) {\n        NetworkInfo storage network = networks[networkIds[i]];\n        \n        if (!network.active) continue;\n        \n        try IDragonVRFIntegrator(network.integrator).getLatestRandomness() returns (uint256 randomness, uint256 round) {\n            // Only use if this is new randomness\n            if (round > network.lastRound) {\n                // Apply weighted randomness\n                randomSeed = uint256(keccak256(abi.encodePacked(\n                    randomSeed, \n                    randomness, \n                    round, \n                    network.weight\n                )));\n                \n                // Update network info\n                network.lastValue = randomness;\n                network.lastRound = round;\n                network.lastUpdate = block.timestamp;\n                \n                totalWeight += network.weight;\n                activeNetworks++;\n            }\n        } catch {\n            // Skip networks that fail\n        }\n    }\n    \n    // Only update if we processed at least one active network\n    if (activeNetworks > 0) {\n        // Final pass by mixing with a counter to ensure uniqueness even with the same inputs\n        aggregationCounter++;\n        aggregatedRandomness = uint256(keccak256(abi.encodePacked(\n            randomSeed, \n            block.timestamp, \n            block.difficulty, \n            totalWeight,\n            aggregationCounter\n        )));\n        \n        lastAggregationTimestamp = block.timestamp;\n        \n        emit RandomnessAggregated(block.timestamp, aggregatedRandomness);\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"consumer-interface",children:"Consumer Interface"}),"\n",(0,s.jsx)(n.p,{children:"Consumer contracts interact with the OmniDragonVRFConsumer using this interface:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:'/**\n * @dev Request randomness (helper function for consumers)\n * @param _consumer The consumer address\n */\nfunction requestRandomness(address _consumer) external override returns (uint256) {\n    require(authorizedConsumers[_consumer], "Consumer not authorized");\n    \n    uint256 requestId = uint256(keccak256(abi.encodePacked(\n        _consumer,\n        blockhash(block.number - 1),\n        aggregationCounter,\n        block.timestamp\n    )));\n    \n    emit RandomnessRequested(_consumer, requestId);\n    \n    // Try to fulfill immediately\n    try this.fulfillRandomness(_consumer, requestId) {\n        // Succeeded\n    } catch {\n        // Will need to be fulfilled later\n    }\n    \n    return requestId;\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"fulfillment-logic",children:"Fulfillment Logic"}),"\n",(0,s.jsx)(n.p,{children:"The contract fulfills randomness requests using this function:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:'/**\n * @dev Fulfill a randomness request for a consumer\n * @param _consumer The consumer address\n * @param _requestId The ID of the request\n */\nfunction fulfillRandomness(address _consumer, uint256 _requestId) external override nonReentrant {\n    require(msg.sender == owner() || authorizedConsumers[msg.sender], "Not authorized");\n    \n    // Aggregate if it\'s been a while since last update\n    if (block.timestamp - lastAggregationTimestamp > 30) {\n        aggregateRandomness();\n    }\n    \n    // Derive unique randomness for this request\n    uint256 uniqueRandomness = uint256(keccak256(abi.encodePacked(\n        aggregatedRandomness,\n        _consumer,\n        _requestId,\n        block.timestamp\n    )));\n    \n    // Send it to the consumer\n    try IDragonVRFConsumer(_consumer).fulfillRandomness(_requestId, uniqueRandomness, aggregationCounter) {\n        emit RandomnessFulfilled(_consumer, _requestId, uniqueRandomness);\n    } catch {\n        // Ignore failures\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"security-features",children:"Security Features"}),"\n",(0,s.jsx)(n.p,{children:"The OmniDragonVRFConsumer implements several security measures:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Access Control"}),": Only authorized consumers can request randomness"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"function setAuthorizedConsumer(address _consumer, bool _authorized) external onlyOwner {\n    authorizedConsumers[_consumer] = _authorized;\n    emit ConsumerAuthorized(_consumer, _authorized);\n}\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Reentrancy Protection"}),": Uses ReentrancyGuard to prevent reentrant calls"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"function fulfillRandomness(address _consumer, uint256 _requestId) external override nonReentrant {\n    // Implementation\n}\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Error Handling"}),": Gracefully handles failures from external contracts"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"try IDragonVRFIntegrator(network.integrator).getLatestRandomness() returns (uint256 randomness, uint256 round) {\n    // Success handling\n} catch {\n    // Skip networks that fail\n}\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Uniqueness Guarantee"}),": Uses a monotonically increasing counter to ensure uniqueness"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"aggregationCounter++;\naggregatedRandomness = uint256(keccak256(abi.encodePacked(\n    randomSeed, \n    block.timestamp, \n    block.difficulty, \n    totalWeight,\n    aggregationCounter\n)));\n"})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"events",children:"Events"}),"\n",(0,s.jsx)(n.p,{children:"The contract emits the following events:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"// Network management events\nevent NetworkAdded(bytes32 indexed networkId, address integrator, uint256 weight);\nevent NetworkUpdated(bytes32 indexed networkId, address integrator, uint256 weight, bool active);\nevent NetworkRemoved(bytes32 indexed networkId);\n\n// Randomness events\nevent RandomnessAggregated(uint256 timestamp, uint256 value);\nevent ConsumerAuthorized(address consumer, bool authorized);\nevent RandomnessRequested(address consumer, uint256 requestId);\nevent RandomnessFulfilled(address consumer, uint256 requestId, uint256 randomness);\n"})}),"\n",(0,s.jsx)(n.h2,{id:"consumer-integration",children:"Consumer Integration"}),"\n",(0,s.jsx)(n.p,{children:"To integrate with the OmniDragonVRFConsumer, contracts should implement this interface:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"interface IDragonVRFConsumer {\n    function fulfillRandomness(uint256 requestId, uint256 randomness, uint256 round) external;\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"usage-example",children:"Usage Example"}),"\n",(0,s.jsx)(n.p,{children:"Here's how a consumer contract would use the OmniDragonVRFConsumer:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:'// Consumer contract that uses OmniDragonVRFConsumer\ncontract RandomnessConsumer is IDragonVRFConsumer {\n    IOmniDragonVRFConsumer public omniConsumer;\n    \n    mapping(uint256 => bool) public pendingRequests;\n    uint256 public lastRandomValue;\n    \n    constructor(address _omniConsumer) {\n        omniConsumer = IOmniDragonVRFConsumer(_omniConsumer);\n    }\n    \n    // Request randomness\n    function getRandomNumber() external returns (uint256) {\n        uint256 requestId = omniConsumer.requestRandomness(address(this));\n        pendingRequests[requestId] = true;\n        return requestId;\n    }\n    \n    // Called by the OmniDragonVRFConsumer to fulfill the randomness request\n    function fulfillRandomness(uint256 requestId, uint256 randomness, uint256 round) external override {\n        require(msg.sender == address(omniConsumer), "Only OmniConsumer can fulfill");\n        require(pendingRequests[requestId], "Request not found");\n        \n        lastRandomValue = randomness;\n        delete pendingRequests[requestId];\n        \n        // Use the randomness value\n        // ...\n    }\n}\n'})})]})}function l(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>a});var t=r(6540);const s={},o=t.createContext(s);function i(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);