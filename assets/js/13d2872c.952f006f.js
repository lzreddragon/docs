"use strict";(self.webpackChunksonic_red_dragon_docs=self.webpackChunksonic_red_dragon_docs||[]).push([[8147],{5537:(e,t,n)=>{n.d(t,{A:()=>C});var i=n(6540),a=n(4164),r=n(5627),s=n(6347),o=n(372),l=n(604),c=n(1861),u=n(8749);function d(e){return i.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,i.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function p(e){const{values:t,children:n}=e;return(0,i.useMemo)((()=>{const e=t??function(e){return d(e).map((({props:{value:e,label:t,attributes:n,default:i}})=>({value:e,label:t,attributes:n,default:i})))}(n);return function(e){const t=(0,c.XI)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function m({value:e,tabValues:t}){return t.some((t=>t.value===e))}function h({queryString:e=!1,groupId:t}){const n=(0,s.W6)(),a=function({queryString:e=!1,groupId:t}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:e,groupId:t});return[(0,l.aZ)(a),(0,i.useCallback)((e=>{if(!a)return;const t=new URLSearchParams(n.location.search);t.set(a,e),n.replace({...n.location,search:t.toString()})}),[a,n])]}function v(e){const{defaultValue:t,queryString:n=!1,groupId:a}=e,r=p(e),[s,l]=(0,i.useState)((()=>function({defaultValue:e,tabValues:t}){if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!m({value:e,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const n=t.find((e=>e.default))??t[0];if(!n)throw new Error("Unexpected error: 0 tabValues");return n.value}({defaultValue:t,tabValues:r}))),[c,d]=h({queryString:n,groupId:a}),[v,f]=function({groupId:e}){const t=function(e){return e?`docusaurus.tab.${e}`:null}(e),[n,a]=(0,u.Dv)(t);return[n,(0,i.useCallback)((e=>{t&&a.set(e)}),[t,a])]}({groupId:a}),g=(()=>{const e=c??v;return m({value:e,tabValues:r})?e:null})();(0,o.A)((()=>{g&&l(g)}),[g]);return{selectedValue:s,selectValue:(0,i.useCallback)((e=>{if(!m({value:e,tabValues:r}))throw new Error(`Can't select invalid tab value=${e}`);l(e),d(e),f(e)}),[d,f,r]),tabValues:r}}var f=n(9136);const g={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var x=n(4848);function y({className:e,block:t,selectedValue:n,selectValue:i,tabValues:s}){const o=[],{blockElementScrollPositionUntilNextRender:l}=(0,r.a_)(),c=e=>{const t=e.currentTarget,a=o.indexOf(t),r=s[a].value;r!==n&&(l(t),i(r))},u=e=>{let t=null;switch(e.key){case"Enter":c(e);break;case"ArrowRight":{const n=o.indexOf(e.currentTarget)+1;t=o[n]??o[0];break}case"ArrowLeft":{const n=o.indexOf(e.currentTarget)-1;t=o[n]??o[o.length-1];break}}t?.focus()};return(0,x.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,a.A)("tabs",{"tabs--block":t},e),children:s.map((({value:e,label:t,attributes:i})=>(0,x.jsx)("li",{role:"tab",tabIndex:n===e?0:-1,"aria-selected":n===e,ref:e=>{o.push(e)},onKeyDown:u,onClick:c,...i,className:(0,a.A)("tabs__item",g.tabItem,i?.className,{"tabs__item--active":n===e}),children:t??e},e)))})}function b({lazy:e,children:t,selectedValue:n}){const r=(Array.isArray(t)?t:[t]).filter(Boolean);if(e){const e=r.find((e=>e.props.value===n));return e?(0,i.cloneElement)(e,{className:(0,a.A)("margin-top--md",e.props.className)}):null}return(0,x.jsx)("div",{className:"margin-top--md",children:r.map(((e,t)=>(0,i.cloneElement)(e,{key:t,hidden:e.props.value!==n})))})}function j(e){const t=v(e);return(0,x.jsxs)("div",{className:(0,a.A)("tabs-container",g.tabList),children:[(0,x.jsx)(y,{...t,...e}),(0,x.jsx)(b,{...t,...e})]})}function C(e){const t=(0,f.A)();return(0,x.jsx)(j,{...e,children:d(e.children)},String(t))}},5678:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>c,default:()=>m,frontMatter:()=>l,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"contracts/math/adaptive-fee","title":"DragonAdaptiveFeeManager","description":"Dynamic fee adjustment system that responds to market conditions and protocol metrics","source":"@site/docs/contracts/math/adaptive-fee.md","sourceDirName":"contracts/math","slug":"/contracts/math/adaptive-fee","permalink":"/contracts/math/adaptive-fee","draft":false,"unlisted":false,"editUrl":"https://github.com/wenakita/sonicreddragon-docs/edit/main/docs/contracts/math/adaptive-fee.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6,"title":"DragonAdaptiveFeeManager","description":"Dynamic fee adjustment system that responds to market conditions and protocol metrics"},"sidebar":"contracts","previous":{"title":"DragonDateTimeLib","permalink":"/contracts/math/date-time-lib"},"next":{"title":"Math","permalink":"/contracts/utils/math"}}');var a=n(4848),r=n(8453),s=n(5537),o=n(9329);const l={sidebar_position:6,title:"DragonAdaptiveFeeManager",description:"Dynamic fee adjustment system that responds to market conditions and protocol metrics"},c="DragonAdaptiveFeeManager",u={},d=[{value:"Overview",id:"overview",level:2},{value:"Key Functions",id:"key-functions",level:2},{value:"Adaptive Fee System",id:"adaptive-fee-system",level:2},{value:"Response Curves",id:"response-curves",level:2},{value:"Volatility Response",id:"volatility-response",level:3},{value:"Liquidity Response",id:"liquidity-response",level:3},{value:"Integration Examples",id:"integration-examples",level:2},{value:"Basic Fee Calculation",id:"basic-fee-calculation",level:3},{value:"Dynamic Fee Distribution",id:"dynamic-fee-distribution",level:3},{value:"Dynamic Range Control",id:"dynamic-range-control",level:2},{value:"Gas Optimization",id:"gas-optimization",level:2}];function p(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"dragonadaptivefeemanager",children:"DragonAdaptiveFeeManager"})}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"Dynamic fee adjustment system that responds to market conditions and protocol metrics"})}),"\n",(0,a.jsxs)("div",{className:"contract-badges",children:[(0,a.jsx)("span",{className:"contract-badge fee",children:"Fee Management"}),(0,a.jsx)("span",{className:"contract-badge market",children:"Market Responsive"}),(0,a.jsx)("span",{className:"contract-badge adaptive",children:"Adaptive System"})]}),"\n",(0,a.jsx)(t.h2,{id:"overview",children:"Overview"}),"\n",(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.code,{children:"DragonAdaptiveFeeManager"})," implements a sophisticated dynamic fee adjustment system that automatically calibrates protocol fees based on market conditions, user behavior, and protocol health metrics."]}),"\n",(0,a.jsx)(t.mermaid,{value:'flowchart TB\n    subgraph "Input Metrics"\n        Volume["Trading Volume"]\n        Volatility["Market Volatility"]\n        Liquidity["Liquidity Depth"]\n        UserActivity["User Activity"]\n    end\n    \n    subgraph "Processing Layer"\n        BaseRate["Base Fee Rate"]\n        Modifiers["Fee Modifiers"]\n        Thresholds["Adaptive Thresholds"]\n        Calculation["Fee Calculation"]\n    end\n    \n    subgraph "Output Controls"\n        SwapFee["Swap Fee"]\n        JackpotRate["Jackpot Allocation"]\n        LPRate["LP Rewards Allocation"]\n        BurnRate["Burn Rate"]\n    end\n    \n    Volume --\x3e Calculation\n    Volatility --\x3e Calculation\n    Liquidity --\x3e Calculation\n    UserActivity --\x3e Calculation\n    \n    BaseRate --\x3e Calculation\n    Modifiers --\x3e Calculation\n    Thresholds --\x3e Calculation\n    \n    Calculation --\x3e SwapFee\n    Calculation --\x3e JackpotRate\n    Calculation --\x3e LPRate\n    Calculation --\x3e BurnRate\n    \n    class Calculation highlight'}),"\n",(0,a.jsx)(t.h2,{id:"key-functions",children:"Key Functions"}),"\n",(0,a.jsx)(t.p,{children:"The library provides a suite of functions for dynamic fee management."}),"\n",(0,a.jsx)("div",{className:"function-signature",children:(0,a.jsx)(t.p,{children:"function calculateAdaptiveFee(uint256 baseFeeBps, uint256 volatility, uint256 liquidity, uint256 volume) internal pure returns (uint256)"})}),"\n",(0,a.jsx)(t.p,{children:"Calculates the optimal fee rate by considering market volatility, liquidity depth, and trading volume."}),"\n",(0,a.jsx)("div",{className:"function-signature",children:(0,a.jsx)(t.p,{children:"function calculateFeeDistribution(uint256 totalFeeBps, uint256 jackpotSize, uint256 lpRatio) internal pure returns (FeeDistribution memory)"})}),"\n",(0,a.jsx)(t.p,{children:"Determines how collected fees should be distributed between jackpot, LP rewards, and token burning."}),"\n",(0,a.jsx)("div",{className:"function-signature",children:(0,a.jsx)(t.p,{children:"function calculateVolatilityMetric(uint256[] memory prices, uint256 timeWindow) internal pure returns (uint256)"})}),"\n",(0,a.jsx)(t.p,{children:"Computes a normalized volatility metric based on recent price movements."}),"\n",(0,a.jsx)(t.h2,{id:"adaptive-fee-system",children:"Adaptive Fee System"}),"\n",(0,a.jsxs)(s.A,{children:[(0,a.jsxs)(o.A,{value:"formula",label:"Core Fee Formula",default:!0,children:[(0,a.jsx)("div",{className:"math-formula",children:(0,a.jsx)(t.p,{children:"fee = baseFeeBps * (1 + volModifier - liqModifier + volumeModifier)"})}),(0,a.jsx)("p",{children:"The core formula adjusts the base fee by applying modifiers derived from market conditions."})]}),(0,a.jsxs)(o.A,{value:"volatility",label:"Volatility Modifier",children:[(0,a.jsx)("div",{className:"math-formula",children:(0,a.jsx)(t.p,{children:"volModifier = volatility / VOLATILITY_SCALE * MAX_VOL_IMPACT"})}),(0,a.jsx)("p",{children:"Higher volatility increases fees to compensate for increased market risk."})]}),(0,a.jsxs)(o.A,{value:"liquidity",label:"Liquidity Modifier",children:[(0,a.jsx)("div",{className:"math-formula",children:(0,a.jsx)(t.p,{children:"liqModifier = min(liquidityDepth / TARGET_LIQUIDITY * MAX_LIQ_DISCOUNT, MAX_LIQ_DISCOUNT)"})}),(0,a.jsx)("p",{children:"Higher liquidity decreases fees to incentivize trading in well-capitalized pools."})]})]}),"\n",(0,a.jsx)(t.h2,{id:"response-curves",children:"Response Curves"}),"\n",(0,a.jsx)(t.p,{children:"The adaptive fee system employs several response curves to ensure optimal protocol behavior:"}),"\n",(0,a.jsx)(t.h3,{id:"volatility-response",children:"Volatility Response"}),"\n",(0,a.jsx)(t.mermaid,{value:'flowchart LR\n    subgraph "Volatility Impact on Fees"\n        direction TB\n        Inputs["Market Volatility"] --\x3e Curve["Response Curve"]\n        Curve --\x3e Output["Fee Modifier"]\n    end\n    \n    Curve --- Low["Low (+0%)"]\n    Curve --- Medium["Medium (+0.1%)"]\n    Curve --- High["High (+0.25%)"]\n    Curve --- Extreme["Extreme (+0.4%)"]\n    \n    class Curve highlight'}),"\n",(0,a.jsx)(t.p,{children:"As market volatility increases, fees are proportionally increased to compensate for increased risk and provide additional jackpot funding."}),"\n",(0,a.jsx)(t.h3,{id:"liquidity-response",children:"Liquidity Response"}),"\n",(0,a.jsx)(t.mermaid,{value:'flowchart LR\n    subgraph "Liquidity Impact on Fees"\n        direction TB\n        Inputs["Liquidity Depth"] --\x3e Curve["Response Curve"]\n        Curve --\x3e Output["Fee Discount"]\n    end\n    \n    Curve --- Low["Low (0%)"]\n    Curve --- Medium["Medium (-0.05%)"]\n    Curve --- High["High (-0.1%)"]\n    Curve --- Deep["Deep (-0.15%)"]\n    \n    class Curve highlight'}),"\n",(0,a.jsx)(t.p,{children:"Deeper liquidity results in fee discounts to incentivize trading in well-capitalized pools."}),"\n",(0,a.jsx)(t.h2,{id:"integration-examples",children:"Integration Examples"}),"\n",(0,a.jsx)(t.h3,{id:"basic-fee-calculation",children:"Basic Fee Calculation"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:'// Import the library\nimport "../math/DragonAdaptiveFeeManager.sol";\n\ncontract TradingProtocol {\n    using DragonAdaptiveFeeManager for uint256;\n    \n    // Base protocol parameters\n    uint256 public constant BASE_FEE_BPS = 30; // 0.3%\n    \n    // Market metrics\n    uint256 public lastVolatility;\n    uint256 public lastLiquidityDepth;\n    uint256 public last24hVolume;\n    \n    // Calculate the current fee for a trade\n    function getCurrentFee() public view returns (uint256) {\n        return DragonAdaptiveFeeManager.calculateAdaptiveFee(\n            BASE_FEE_BPS,\n            lastVolatility,\n            lastLiquidityDepth,\n            last24hVolume\n        );\n    }\n    \n    // Update market metrics (called by oracle)\n    function updateMarketMetrics(\n        uint256 volatility,\n        uint256 liquidityDepth,\n        uint256 volume\n    ) external onlyOracle {\n        lastVolatility = volatility;\n        lastLiquidityDepth = liquidityDepth;\n        last24hVolume = volume;\n    }\n}\n'})}),"\n",(0,a.jsx)(t.h3,{id:"dynamic-fee-distribution",children:"Dynamic Fee Distribution"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:'// Import the library\nimport "../math/DragonAdaptiveFeeManager.sol";\n\ncontract FeeDistributor {\n    using DragonAdaptiveFeeManager for uint256;\n    \n    // Protocol state\n    uint256 public jackpotSize;\n    uint256 public lpRatio; // Ratio of LP tokens to total supply\n    \n    // Distribute collected fees\n    function distributeFees(uint256 collectedFees) external returns (\n        uint256 toJackpot,\n        uint256 toLPs,\n        uint256 toBurn\n    ) {\n        // Calculate the optimal distribution\n        DragonAdaptiveFeeManager.FeeDistribution memory dist = \n            DragonAdaptiveFeeManager.calculateFeeDistribution(\n                collectedFees,\n                jackpotSize,\n                lpRatio\n            );\n        \n        // Transfer funds to respective destinations\n        // ... (implementation)\n        \n        return (dist.jackpotAmount, dist.lpAmount, dist.burnAmount);\n    }\n}\n'})}),"\n",(0,a.jsx)(t.h2,{id:"dynamic-range-control",children:"Dynamic Range Control"}),"\n",(0,a.jsx)(t.p,{children:"The adaptive fee system implements dynamic range controls to ensure fees remain within acceptable bounds:"}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Minimum Fee"}),": Ensures protocol sustainability by maintaining a floor fee rate"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Maximum Fee"}),": Prevents user friction by capping maximum fees during extreme conditions"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Response Dampening"}),": Smooths fee changes to prevent rapid oscillations"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Time-Weighted Adjustments"}),": Incorporates historical data to avoid reactionary changes"]}),"\n"]}),"\n",(0,a.jsxs)("div",{className:"security-consideration",children:[(0,a.jsx)("h4",{children:"Security Considerations"}),(0,a.jsx)("p",{children:"When implementing the adaptive fee system, consider these security best practices:"}),(0,a.jsxs)("ul",{children:[(0,a.jsxs)("li",{children:[(0,a.jsx)("strong",{children:"Oracle Security"}),": Ensure market metrics cannot be manipulated by malicious actors"]}),(0,a.jsxs)("li",{children:[(0,a.jsx)("strong",{children:"Bounds Validation"}),": Implement strict minimum and maximum bounds on all fee parameters"]}),(0,a.jsxs)("li",{children:[(0,a.jsx)("strong",{children:"Smoothing Algorithm"}),": Use time-weighted average prices (TWAP) to resist manipulation"]}),(0,a.jsxs)("li",{children:[(0,a.jsx)("strong",{children:"Circuit Breakers"}),": Implement emergency controls for extreme market conditions"]}),(0,a.jsxs)("li",{children:[(0,a.jsx)("strong",{children:"Governance Controls"}),": Allow parameter adjustments through secure governance process"]})]})]}),"\n",(0,a.jsx)(t.h2,{id:"gas-optimization",children:"Gas Optimization"}),"\n",(0,a.jsxs)("div",{className:"gas-optimization",children:[(0,a.jsx)("h4",{children:"Gas Optimization Notes"}),(0,a.jsx)("p",{children:"The adaptive fee system implements several gas optimizations:"}),(0,a.jsxs)("ul",{children:[(0,a.jsx)("li",{children:"Caching of market metrics between updates"}),(0,a.jsx)("li",{children:"Efficient fixed-point arithmetic for fee calculations"}),(0,a.jsx)("li",{children:"Batched updates of related parameters"}),(0,a.jsx)("li",{children:"Precalculated scaling factors for common operations"}),(0,a.jsx)("li",{children:"Minimal state changes during high-frequency operations"})]})]})]})}function m(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(p,{...e})}):p(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>o});var i=n(6540);const a={},r=i.createContext(a);function s(e){const t=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),i.createElement(r.Provider,{value:t},e.children)}},9329:(e,t,n)=>{n.d(t,{A:()=>s});n(6540);var i=n(4164);const a={tabItem:"tabItem_Ymn6"};var r=n(4848);function s({children:e,hidden:t,className:n}){return(0,r.jsx)("div",{role:"tabpanel",className:(0,i.A)(a.tabItem,n),hidden:t,children:e})}}}]);