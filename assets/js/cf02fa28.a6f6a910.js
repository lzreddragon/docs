"use strict";(self.webpackChunksonic_red_dragon_docs=self.webpackChunksonic_red_dragon_docs||[]).push([[1007],{2197:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>s,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"contracts/jackpot/triggers","title":"Swap-Based Jackpot Trigger System","description":"The OmniDragon ecosystem uses a sophisticated swap-based trigger system implemented in the OmniDragonSwapTriggerOracle contract to determine lottery entries and potential jackpot winners.","source":"@site/docs/contracts/jackpot/triggers.md","sourceDirName":"contracts/jackpot","slug":"/contracts/jackpot/triggers","permalink":"/contracts/jackpot/triggers","draft":false,"unlisted":false,"editUrl":"https://github.com/wenakita/sonicreddragon-docs/edit/main/docs/contracts/jackpot/triggers.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4,"title":"Swap-Based Jackpot Trigger System"},"sidebar":"contracts","previous":{"title":"Swap Trigger Oracle","permalink":"/contracts/jackpot/trigger"},"next":{"title":"OmniDragonVRFConsumer","permalink":"/contracts/oracles/vrf-consumer"}}');var a=r(4848),t=r(8453);const s={sidebar_position:4,title:"Swap-Based Jackpot Trigger System"},o="Swap-Based Jackpot Trigger System",l={},c=[{value:"Architecture Overview",id:"architecture-overview",level:2},{value:"Swap-Based Trigger Mechanism",id:"swap-based-trigger-mechanism",level:2},{value:"Probability Calculation",id:"probability-calculation",level:2},{value:"Oracle Price Aggregation",id:"oracle-price-aggregation",level:2},{value:"Anti-Abuse Mechanisms",id:"anti-abuse-mechanisms",level:2},{value:"Trigger Configuration",id:"trigger-configuration",level:2},{value:"Implementation Details",id:"implementation-details",level:2},{value:"Trigger Process Flow",id:"trigger-process-flow",level:2},{value:"Key Features",id:"key-features",level:2},{value:"Integration Example",id:"integration-example",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,t.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"swap-based-jackpot-trigger-system",children:"Swap-Based Jackpot Trigger System"})}),"\n",(0,a.jsxs)(n.p,{children:["The OmniDragon ecosystem uses a sophisticated swap-based trigger system implemented in the ",(0,a.jsx)(n.code,{children:"OmniDragonSwapTriggerOracle"})," contract to determine lottery entries and potential jackpot winners."]}),"\n",(0,a.jsx)(n.h2,{id:"architecture-overview",children:"Architecture Overview"}),"\n",(0,a.jsx)(n.p,{children:"The OmniDragon trigger system uses a price-aware, swap-activity monitoring approach to create a fair and engaging lottery experience:"}),"\n",(0,a.jsx)(n.mermaid,{value:'flowchart TB\n    %% Define main components of the trigger system\n    subgraph TriggerCore ["Trigger Contract"]\n        direction TB\n        INTERFACE["IOmniDragonSwapTriggerOracle"]:::interface\n        SWAP_ORACLE["OmniDragonSwapTriggerOracle"]:::impl\n    end\n    \n    subgraph OracleSources ["Price Oracles"]\n        direction TB\n        CHAINLINK["Chainlink Feed"]:::oracle\n        API3["API3 Feed"]:::oracle\n        BAND["Band Protocol"]:::oracle\n        PYTH["Pyth Network"]:::oracle\n        STORK["Stork Network"]:::oracle\n    end\n    \n    subgraph Mechanisms ["Probability Mechanisms"]\n        direction TB\n        BASE_PROB["Base Probability"]:::mechanism\n        SWAP_SIZE["Swap Size Bonus"]:::mechanism\n        LOGARITHMIC["Logarithmic Scaling"]:::mechanism\n        MAX_CAP["Maximum Probability Cap"]:::mechanism\n    end\n    \n    %% Connect the systems\n    OracleSources --\x3e|"Price Data"| SWAP_ORACLE\n    INTERFACE --\x3e|"Implemented by"| SWAP_ORACLE\n    Mechanisms --\x3e|"Determines Win Chance"| SWAP_ORACLE\n    \n    %% Connect to external systems\n    OMNI_DRAGON["OmniDragon Token"]:::external\n    JACKPOT_VAULT["Jackpot Vault"]:::external\n    OFF_CHAIN["Off-Chain Random Selection"]:::external\n    \n    OMNI_DRAGON --\x3e|"Calls on Swap"| SWAP_ORACLE\n    SWAP_ORACLE --\x3e|"Emits Events"| OFF_CHAIN\n    SWAP_ORACLE -.->|"Can Interact with"| JACKPOT_VAULT\n    \n    %% Apply styling\n    classDef interface fill:#e3f2fd,stroke:#1e88e5,color:#0d47a1\n    classDef impl fill:#e8f5e9,stroke:#43a047,color:#1b5e20\n    classDef oracle fill:#f3e5f5,stroke:#8e24aa,color:#4a148c\n    classDef mechanism fill:#fff8e1,stroke:#ffb300,color:#ff6f00\n    classDef external fill:#fce4ec,stroke:#ec407a,color:#880e4f\n    \n    %% Style subgraphs\n    style TriggerCore fill:#e3f2fd,stroke:#bbdefb,color:#1565c0\n    style OracleSources fill:#f3e5f5,stroke:#e1bee7,color:#6a1b9a\n    style Mechanisms fill:#fff8e1,stroke:#ffecb3,color:#ff8f00'}),"\n",(0,a.jsx)(n.h2,{id:"swap-based-trigger-mechanism",children:"Swap-Based Trigger Mechanism"}),"\n",(0,a.jsx)(n.p,{children:"The OmniDragon system uses token swap activity to trigger lottery entries, with the probability of winning proportional to swap size:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-solidity",children:'function onSwap(address user, uint256 amount) external override onlyOmniDragon nonReentrant {\n    require(user != address(0), "Zero user");\n    require(amount >= minSwapAmount, "Swap too small");\n    require(block.timestamp >= lastEntry[user] + cooldownPeriod, "Cooldown active");\n\n    // Calculate win probability for this swap\n    uint256 probability = calculateWinProbability(amount);\n    \n    // Update user\'s recorded probability\n    userWinProbability[user] = probability;\n    \n    // Update statistics for future calculations\n    _updateSwapStatistics(amount);\n    \n    // Record entry time\n    lastEntry[user] = block.timestamp;\n\n    emit LotteryEntry(user, amount, block.timestamp, probability);\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"probability-calculation",children:"Probability Calculation"}),"\n",(0,a.jsx)(n.p,{children:"The trigger system uses a sophisticated algorithm that calculates win probability based on swap amount and market conditions:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-solidity",children:"function calculateWinProbability(uint256 amount) public view returns (uint256) {\n    // If we don't have enough data yet, return base probability\n    if (swapCount < 10 || averageSwapAmount == 0) {\n        return baseWinProbability;\n    }\n    \n    // Get aggregated price from oracles\n    (int256 price, bool priceSuccess) = getAggregatedPrice();\n    \n    // If price aggregation failed, use base probability\n    if (!priceSuccess || price <= 0) {\n        return baseWinProbability;\n    }\n    \n    // Calculate ratio of this swap to average (scaled by 10000)\n    uint256 swapRatio = (amount * 10000) / averageSwapAmount;\n    \n    // Calculate probability with logarithmic scaling\n    uint256 probability;\n    \n    if (swapRatio <= 10000) {\n        // For swaps below average, linear scale between base and 2x base\n        probability = baseWinProbability + ((baseWinProbability * swapRatio) / 10000);\n    } else {\n        // For swaps above average, logarithmic scale with diminishing returns\n        uint256 logFactor = 10000 * (1 + _log2(swapRatio / 10000));\n        probability = baseWinProbability + (baseWinProbability * logFactor) / 10000;\n    }\n    \n    // Cap at maximum probability\n    return probability > maxWinProbability ? maxWinProbability : probability;\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"oracle-price-aggregation",children:"Oracle Price Aggregation"}),"\n",(0,a.jsx)(n.p,{children:"The system uses multiple trusted price oracles to determine fair market values, which helps ensure the probability calculations are accurate:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-solidity",children:"function getAggregatedPrice() public view returns (int256 aggregatedPrice, bool success) {\n    int256[] memory prices = new int256[](activeOracleCount);\n    uint8 validPrices = 0;\n    \n    // Collect prices from all active oracles\n    for (uint8 i = 0; i < 10; i++) {\n        if (oracleSources[i].isActive) {\n            (int256 price, bool priceSuccess) = getPriceFromOracle(i);\n            \n            if (priceSuccess && price > 0) {\n                prices[validPrices] = price;\n                validPrices++;\n            }\n        }\n    }\n    \n    // Check if we have enough valid prices\n    if (validPrices < minimumOracleResponses) {\n        return (0, false);\n    }\n    \n    // Sort prices to find median\n    // ... (sorting algorithm)\n    \n    // Calculate median price\n    if (validPrices % 2 == 0) {\n        // Even number of prices, average the middle two\n        aggregatedPrice = (prices[validPrices / 2 - 1] + prices[validPrices / 2]) / 2;\n    } else {\n        // Odd number of prices, take the middle one\n        aggregatedPrice = prices[validPrices / 2];\n    }\n    \n    return (aggregatedPrice, true);\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"anti-abuse-mechanisms",children:"Anti-Abuse Mechanisms"}),"\n",(0,a.jsx)(n.p,{children:"The trigger system includes several measures to prevent abuse and ensure fair participation:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Minimum Swap Amount"}),": Requires swaps to exceed a configurable minimum amount"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-solidity",children:'require(amount >= minSwapAmount, "Swap too small");\n'})}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"User Cooldown"}),": Prevents users from participating too frequently"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-solidity",children:'require(block.timestamp >= lastEntry[user] + cooldownPeriod, "Cooldown active");\n'})}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Multiple Oracle Consensus"}),": Requires multiple trusted price sources to agree"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-solidity",children:"if (validPrices < minimumOracleResponses) {\n    return (0, false);\n}\n"})}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Logarithmic Scaling"}),": Prevents large swaps from having disproportionate advantages"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-solidity",children:"uint256 logFactor = 10000 * (1 + _log2(swapRatio / 10000));\n"})}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Maximum Probability Cap"}),": Ensures even large swaps have a maximum win probability"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-solidity",children:"return probability > maxWinProbability ? maxWinProbability : probability;\n"})}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"trigger-configuration",children:"Trigger Configuration"}),"\n",(0,a.jsx)(n.p,{children:"The system can be configured with these parameters:"}),"\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"Parameter"}),(0,a.jsx)(n.th,{children:"Description"}),(0,a.jsx)(n.th,{children:"Default"}),(0,a.jsx)(n.th,{children:"Range"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"minSwapAmount"})}),(0,a.jsx)(n.td,{children:"Minimum swap size to qualify"}),(0,a.jsx)(n.td,{children:"Configurable"}),(0,a.jsx)(n.td,{children:"> 0"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"cooldownPeriod"})}),(0,a.jsx)(n.td,{children:"User cooldown between entries (seconds)"}),(0,a.jsx)(n.td,{children:"Configurable"}),(0,a.jsx)(n.td,{children:"> 0"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"baseWinProbability"})}),(0,a.jsx)(n.td,{children:"Base win probability (basis points)"}),(0,a.jsx)(n.td,{children:"100 (1%)"}),(0,a.jsx)(n.td,{children:"0-10000"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"maxWinProbability"})}),(0,a.jsx)(n.td,{children:"Maximum win chance (basis points)"}),(0,a.jsx)(n.td,{children:"1000 (10%)"}),(0,a.jsx)(n.td,{children:"> baseWinProbability"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"minimumOracleResponses"})}),(0,a.jsx)(n.td,{children:"Minimum required oracle responses"}),(0,a.jsx)(n.td,{children:"1"}),(0,a.jsx)(n.td,{children:"1-activeOracleCount"})]})]})]}),"\n",(0,a.jsx)(n.h2,{id:"implementation-details",children:"Implementation Details"}),"\n",(0,a.jsx)(n.p,{children:"The OmniDragonSwapTriggerOracle contract inherits from multiple OpenZeppelin contracts for security and extensibility:"}),"\n",(0,a.jsx)(n.mermaid,{value:"classDiagram\n    %% Define the contract hierarchy\n    class Ownable {\n        <<OpenZeppelin>>\n        +owner: address\n        +transferOwnership(address)\n        +onlyOwner() modifier\n    }\n    \n    class ReentrancyGuard {\n        <<OpenZeppelin>>\n        +nonReentrant() modifier\n    }\n    \n    class IOmniDragonSwapTriggerOracle {\n        <<interface>>\n        +onSwap(address user, uint256 amount)\n    }\n    \n    class OmniDragonSwapTriggerOracle {\n        -omniDragon: address\n        -jackpotVault: address\n        -minSwapAmount: uint256\n        -cooldownPeriod: uint256\n        -baseWinProbability: uint256\n        -maxWinProbability: uint256\n        -oracleSources: mapping\n        -activeOracleCount: uint8\n        -userWinProbability: mapping\n        -lastEntry: mapping\n        +onSwap(address, uint256)\n        +calculateWinProbability(uint256)\n        +getAggregatedPrice()\n        +getUserWinProbability(address)\n        +setMinSwapAmount(uint256)\n        +setCooldownPeriod(uint256)\n        +addOracle(uint8, address, OracleType, uint8)\n    }\n    \n    Ownable <|-- OmniDragonSwapTriggerOracle\n    ReentrancyGuard <|-- OmniDragonSwapTriggerOracle\n    IOmniDragonSwapTriggerOracle <|.. OmniDragonSwapTriggerOracle\n    \n    %% Additional classes related to the system\n    class AggregatorV3Interface {\n        <<Chainlink>>\n        +latestRoundData()\n    }\n    \n    class IDragonJackpotVault {\n        <<interface>>\n        +addToJackpot(uint256)\n    }\n    \n    OmniDragonSwapTriggerOracle --\x3e AggregatorV3Interface : uses\n    OmniDragonSwapTriggerOracle --\x3e IDragonJackpotVault : can interact with\n    \n    %% Apply styling\n    classDef interface fill:#e3f2fd,stroke:#1e88e5,color:#0d47a1\n    classDef implementation fill:#e8f5e9,stroke:#43a047,color:#1b5e20\n    classDef external fill:#f3e5f5,stroke:#8e24aa,color:#4a148c\n    \n    class IOmniDragonSwapTriggerOracle,IDragonJackpotVault,AggregatorV3Interface interface\n    class OmniDragonSwapTriggerOracle implementation\n    class Ownable,ReentrancyGuard external"}),"\n",(0,a.jsx)(n.h2,{id:"trigger-process-flow",children:"Trigger Process Flow"}),"\n",(0,a.jsx)(n.p,{children:"The swap-to-lottery entry process follows this sequence:"}),"\n",(0,a.jsx)(n.mermaid,{value:"sequenceDiagram\n    participant User\n    participant OmniDragon as OmniDragon Token\n    participant SwapOracle as Swap Trigger Oracle\n    participant PriceOracles as Price Oracles\n    participant OffChain as Off-Chain System\n    \n    %% Style regions\n    rect rgb(233, 245, 255)\n    note over User,OmniDragon: Swap Initiation\n    \n    User->>+OmniDragon: Perform token swap\n    OmniDragon->>OmniDragon: Process swap\n    OmniDragon->>+SwapOracle: onSwap(user, amount)\n    end\n    \n    rect rgb(245, 235, 255)\n    note over SwapOracle,PriceOracles: Eligibility & Probability\n    \n    SwapOracle->>SwapOracle: Check min amount\n    SwapOracle->>SwapOracle: Check user cooldown\n    SwapOracle->>+PriceOracles: getAggregatedPrice()\n    PriceOracles--\x3e>-SwapOracle: Return median price\n    SwapOracle->>SwapOracle: Calculate win probability\n    end\n    \n    rect rgb(242, 255, 235)\n    note over SwapOracle,OffChain: Entry Recording\n    \n    SwapOracle->>SwapOracle: Record user probability\n    SwapOracle->>SwapOracle: Update swap statistics\n    SwapOracle->>SwapOracle: Update last entry time\n    SwapOracle->>OffChain: Emit LotteryEntry event\n    end\n    \n    SwapOracle--\x3e>-OmniDragon: Return\n    OmniDragon--\x3e>-User: Complete swap\n    \n    rect rgb(255, 240, 245)\n    note over OffChain,User: Off-Chain Winner Selection\n    \n    OffChain->>OffChain: Monitor entry events\n    OffChain->>OffChain: Periodically select winners\n    OffChain->>User: Notify if selected as winner\n    end"}),"\n",(0,a.jsx)(n.h2,{id:"key-features",children:"Key Features"}),"\n",(0,a.jsx)(n.p,{children:"The OmniDragon swap-based trigger system provides several unique features:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Market-Aware Probabilities"}),": Uses oracle price data to ensure fair calculations"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Proportional Rewards"}),": Larger swaps have higher (but not disproportionate) win chances"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Multi-Oracle Support"}),": Aggregates data from multiple oracles for reliability"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Anti-Abuse Protections"}),": User cooldowns and minimum swap requirements"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Configurable Parameters"}),": Allows fine-tuning of the system as needed"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Emitted Events"}),": Enables off-chain systems to track entries and manage winner selection"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"integration-example",children:"Integration Example"}),"\n",(0,a.jsx)(n.p,{children:"Example of integrating with the swap trigger oracle in a token contract:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-solidity",children:'// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport "./interfaces/IOmniDragonSwapTriggerOracle.sol";\n\ncontract OmniDragonToken {\n    IOmniDragonSwapTriggerOracle public swapTriggerOracle;\n    \n    constructor(address _swapTriggerOracle) {\n        swapTriggerOracle = IOmniDragonSwapTriggerOracle(_swapTriggerOracle);\n    }\n    \n    function _transfer(address from, address to, uint256 amount) internal {\n        // Token transfer implementation\n        \n        // If this is a swap with a DEX or specific contract\n        if (isSwapTransaction(from, to)) {\n            // Trigger lottery entry\n            swapTriggerOracle.onSwap(from, amount);\n        }\n    }\n    \n    function isSwapTransaction(address from, address to) internal view returns (bool) {\n        // Logic to determine if this is a swap\n        // ...\n    }\n}\n'})})]})}function p(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>o});var i=r(6540);const a={},t=i.createContext(a);function s(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);