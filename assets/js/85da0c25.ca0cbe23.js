"use strict";(self.webpackChunksonic_red_dragon_docs=self.webpackChunksonic_red_dragon_docs||[]).push([[9183],{8453:(e,n,r)=>{r.d(n,{R:()=>t,x:()=>o});var i=r(6540);const a={},s=i.createContext(a);function t(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:t(e.components),i.createElement(s.Provider,{value:n},e.children)}},9821:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>t,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"contracts/oracles/drand-integration","title":"drand Network Integration","description":"The OmniDragon ecosystem integrates with the drand randomness beacon network to provide verifiable, unpredictable, and unbiasable random values for critical functions like the jackpot system.","source":"@site/docs/contracts/oracles/drand-integration.md","sourceDirName":"contracts/oracles","slug":"/contracts/oracles/drand-integration","permalink":"/contracts/oracles/drand-integration","draft":false,"unlisted":false,"editUrl":"https://github.com/wenakita/sonicreddragon-docs/edit/main/docs/contracts/oracles/drand-integration.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"contracts","previous":{"title":"DragonVRFLib","permalink":"/contracts/oracles/vrf-lib"},"next":{"title":"Mathematical Framework","permalink":"/contracts/math/overview"}}');var a=r(4848),s=r(8453);const t={sidebar_position:4},o="drand Network Integration",d={},c=[{value:"What is drand?",id:"what-is-drand",level:2},{value:"Integration Architecture",id:"integration-architecture",level:2},{value:"Supported drand Networks",id:"supported-drand-networks",level:2},{value:"League of Entropy Mainnet",id:"league-of-entropy-mainnet",level:3},{value:"Quicknet",id:"quicknet",level:3},{value:"EVMnet",id:"evmnet",level:3},{value:"drand Relay Verifier",id:"drand-relay-verifier",level:2},{value:"BLS Signature Verification",id:"bls-signature-verification",level:2},{value:"On-Chain Contracts",id:"on-chain-contracts",level:2},{value:"DragonVRFIntegrator",id:"dragonvrfintegrator",level:3},{value:"Direct On-Chain Verification",id:"direct-on-chain-verification",level:3},{value:"Relay Service Implementation",id:"relay-service-implementation",level:2},{value:"Security Considerations",id:"security-considerations",level:2},{value:"Benefits for OmniDragon",id:"benefits-for-omnidragon",level:2},{value:"Technical Deep Dive: drand Protocol",id:"technical-deep-dive-drand-protocol",level:2}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"drand-network-integration",children:"drand Network Integration"})}),"\n",(0,a.jsx)(n.p,{children:"The OmniDragon ecosystem integrates with the drand randomness beacon network to provide verifiable, unpredictable, and unbiasable random values for critical functions like the jackpot system."}),"\n",(0,a.jsx)(n.h2,{id:"what-is-drand",children:"What is drand?"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.a,{href:"https://drand.love/",children:"drand"})," is a distributed randomness beacon operated by the ",(0,a.jsx)(n.a,{href:"https://leagueofentropy.com/",children:"League of Entropy"}),", a consortium of research institutions and companies including Protocol Labs, Cloudflare, EPFL, UCL, and others. It provides publicly verifiable random values at regular intervals through a distributed cryptographic protocol."]}),"\n",(0,a.jsx)(n.h2,{id:"integration-architecture",children:"Integration Architecture"}),"\n",(0,a.jsx)(n.p,{children:"The drand integration in OmniDragon consists of several components working together:"}),"\n",(0,a.jsx)(n.mermaid,{value:'flowchart TB\n    subgraph "External drand Networks"\n        LoE["League of Entropy<br>(30s beacon)"]\n        Quicknet["Quicknet<br>(3s beacon)"]\n        EVMnet["EVMnet<br>(EVM-optimized)"]\n    end\n    \n    subgraph "Off-Chain Components"\n        Relay["drand-relay-verifier<br>Service"]\n        Monitor["Beacon Monitor"]\n        BLSVerifier["BLS Signature Verifier"]\n    end\n    \n    subgraph "On-Chain Contracts"\n        Integrator["DragonVRFIntegrator"]\n        OmniConsumer["OmniDragonVRFConsumer"]\n        Applications["Jackpot & Applications"]\n    end\n    \n    LoE --\x3e|"Random Beacon"| Relay\n    Quicknet --\x3e|"Random Beacon"| Relay\n    EVMnet --\x3e|"Random Beacon"| Relay\n    \n    Relay --\x3e|"Verify Signatures"| BLSVerifier\n    Relay --\x3e|"Monitor Rounds"| Monitor\n    \n    Relay --\x3e|"Update Randomness"| Integrator\n    Integrator --\x3e|"Provide Randomness"| OmniConsumer\n    OmniConsumer --\x3e|"Aggregated Randomness"| Applications\n    \n    classDef highlight fill:#4a80d1,stroke:#333,stroke-width:2px,color:white;\n    class Relay,Integrator highlight'}),"\n",(0,a.jsx)(n.h2,{id:"supported-drand-networks",children:"Supported drand Networks"}),"\n",(0,a.jsx)(n.p,{children:"The OmniDragon system integrates with multiple drand networks for enhanced reliability:"}),"\n",(0,a.jsx)(n.h3,{id:"league-of-entropy-mainnet",children:"League of Entropy Mainnet"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Chain Hash"}),": ",(0,a.jsx)(n.code,{children:"8990e7a9aaed2ffed73dbd7092123d6f289930540d7651336225dc172e51b2ce"})]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Period"}),": 30 seconds"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Public Key"}),": ",(0,a.jsx)(n.code,{children:"868f005eb8e6e4ca0a47c8a77ceaa5309a47978a7c71bc5cce96366b5d7a569937c529eeda66c7293784a9402801af31"})]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"quicknet",children:"Quicknet"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Chain Hash"}),": ",(0,a.jsx)(n.code,{children:"52db9ba70e0cc0f6eaf7803dd07447a1f5477735fd3f661792ba94600c84e971"})]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Period"}),": 3 seconds"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Public Key"}),": ",(0,a.jsx)(n.code,{children:"83cf0f2896adee7eb8b5f01fcad3912212c437e0073e911fb90022d3e760183c8c4b450b6a0a6c3ac6a5776a2d1064510d1fec758c921cc22b0e17e63aaf4bcb5ed66304de9cf809bd274ca73bab4af5a6e9c76a4bc09e76eae8991ef5ece45a"})]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"evmnet",children:"EVMnet"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Chain Hash"}),": ",(0,a.jsx)(n.code,{children:"04f1e9062b8a81f848fded9c12306733282b2727ecced50032187751166ec8c3"})]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Period"}),": 3 seconds"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Public Key"}),": ",(0,a.jsx)(n.code,{children:"07e1d1d335df83fa98462005690372c643340060d205306a9aa8106b6bd0b3820557ec32c2ad488e4d4f6008f89a346f18492092ccc0d594610de2732c8b808f0095685ae3a85ba243747b1b2f426049010f6b73a0cf1d389351d5aaaa1047f6297d3a4f9749b33eb2d904c9d9ebf17224150ddd7abd7567a9bec6c74480ee0b"})]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Features"}),": Optimized for EVM chains with BLS-BN254 cryptographic curve support, resulting in lower gas costs for on-chain verification"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"drand-relay-verifier",children:"drand Relay Verifier"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"drand-relay-verifier"})," is a critical off-chain service that:"]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Connects to drand networks to receive randomness beacons"}),"\n",(0,a.jsx)(n.li,{children:"Verifies beacon signatures using BLS cryptography"}),"\n",(0,a.jsx)(n.li,{children:"Relays verified randomness to on-chain contracts"}),"\n",(0,a.jsx)(n.li,{children:"Maintains connection reliability across multiple networks"}),"\n"]}),"\n",(0,a.jsx)(n.mermaid,{value:"sequenceDiagram\n    participant drand as drand Network\n    participant Relay as drand-relay-verifier\n    participant Contract as DragonVRFIntegrator\n    \n    drand->>Relay: New randomness round\n    Relay->>Relay: Verify BLS signature\n    \n    alt Signature Valid\n        Relay->>Contract: updateRandomness(round, value)\n        Contract->>Contract: Store verified randomness\n    else Signature Invalid\n        Relay->>Relay: Log error and skip update\n    end"}),"\n",(0,a.jsx)(n.h2,{id:"bls-signature-verification",children:"BLS Signature Verification"}),"\n",(0,a.jsx)(n.p,{children:"The drand randomness beacons use BLS (Boneh-Lynn-Shacham) signatures, which have the following properties:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Distributed Generation"}),": Multiple parties contribute to signature creation"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Threshold Security"}),": Requires a threshold of participants to create a valid signature"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Public Verifiability"}),": Anyone can verify the signature with the public key"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Uniqueness"}),": For each round, only one valid signature can exist"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"The verification process works as follows:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// Pseudocode for drand beacon verification\nfunction verifyDrandBeacon(publicKey, round, previousSignature, signature) {\n    // Construct the message that was signed\n    // In drand, the message is H(prev_sig || round_number)\n    const message = hash(previousSignature + round);\n    \n    // Verify the BLS signature\n    return blsVerify(publicKey, message, signature);\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"on-chain-contracts",children:"On-Chain Contracts"}),"\n",(0,a.jsx)(n.h3,{id:"dragonvrfintegrator",children:"DragonVRFIntegrator"}),"\n",(0,a.jsx)(n.p,{children:"The DragonVRFIntegrator contract serves as the bridge between the off-chain relay and the on-chain randomness consumers:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-solidity",children:'// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract DragonVRFIntegrator {\n    // drand network information\n    uint256 public latestDrandRound;\n    uint256 public latestDrandValue;\n    uint256 public lastUpdateTimestamp;\n    \n    // Only the owner (relay service) can update randomness\n    function updateRandomness(uint256 _round, uint256 _value) external onlyOwner {\n        require(_round > latestDrandRound, "Round must be newer");\n        \n        latestDrandRound = _round;\n        latestDrandValue = _value;\n        lastUpdateTimestamp = block.timestamp;\n        \n        emit RandomnessUpdated(_round, _value);\n    }\n    \n    // Consumers can retrieve the latest randomness\n    function getLatestRandomness() external view returns (uint256, uint256) {\n        return (latestDrandValue, latestDrandRound);\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"direct-on-chain-verification",children:"Direct On-Chain Verification"}),"\n",(0,a.jsx)(n.p,{children:"For applications requiring direct on-chain verification, an extended version of the integrator can be used:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-solidity",children:'// This is a simplified example - actual implementation would use precompiles or optimized libraries\nfunction verifyAndUpdateRandomness(\n    uint256 round,\n    bytes calldata signature,\n    bytes32 previousSignatureHash\n) external {\n    // Call the BLS verification precompile or library\n    bool isValid = drandVerifier.verify(\n        drandPublicKey,\n        constructMessage(round, previousSignatureHash),\n        signature\n    );\n    \n    require(isValid, "Invalid drand signature");\n    \n    // Calculate randomness value from signature (typically the hash of the signature)\n    uint256 randomness = uint256(keccak256(signature));\n    \n    // Update randomness\n    latestDrandRound = round;\n    latestDrandValue = randomness;\n    lastUpdateTimestamp = block.timestamp;\n    \n    emit RandomnessUpdated(round, randomness);\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"relay-service-implementation",children:"Relay Service Implementation"}),"\n",(0,a.jsx)(n.p,{children:"The drand relay service is implemented as a Node.js application that connects to drand networks, verifies randomness, and updates on-chain contracts:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// Pseudocode for drand relay service\nconst drandClient = new DrandClient({\n    urls: [\n        'https://api.drand.sh',\n        'https://drand.cloudflare.com'\n    ],\n    chainHash: '8990e7a9aaed2ffed73dbd7092123d6f289930540d7651336225dc172e51b2ce'\n});\n\n// Subscribe to new randomness rounds\ndrandClient.watchBeacon((beacon) => {\n    // Verify the beacon signature\n    const isValid = verifyBeacon(beacon);\n    \n    if (isValid) {\n        // Convert the randomness to the format expected by the contract\n        const randomness = convertToUint256(beacon.randomness);\n        \n        // Update the contract with the new randomness\n        dragonVRFIntegrator.updateRandomness(beacon.round, randomness);\n    }\n});\n"})}),"\n",(0,a.jsx)(n.h2,{id:"security-considerations",children:"Security Considerations"}),"\n",(0,a.jsx)(n.p,{children:"The drand integration includes several security measures:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Multiple Networks"}),": Integration with multiple drand networks provides redundancy"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Multiple Relays"}),": Relay services can be operated by different entities"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Round Validation"}),": Contracts only accept newer rounds to prevent replay attacks"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Signature Verification"}),": BLS signatures ensure the randomness comes from drand"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Buffer System"}),": The OmniDragonVRFConsumer's buffer system adds an additional layer of unpredictability"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"benefits-for-omnidragon",children:"Benefits for OmniDragon"}),"\n",(0,a.jsx)(n.p,{children:"The drand integration provides several benefits for the OmniDragon ecosystem:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Verifiable Randomness"}),": All randomness can be cryptographically verified"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Public Transparency"}),": The randomness generation process is transparent and auditable"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Manipulation Resistance"}),": Even protocol operators cannot predict or manipulate the randomness"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Regular Schedule"}),": The predictable timing of randomness generation allows for regular jackpot events"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Cross-Chain Consistency"}),": The same randomness source can be used across multiple blockchains"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"technical-deep-dive-drand-protocol",children:"Technical Deep Dive: drand Protocol"}),"\n",(0,a.jsx)(n.p,{children:"At a technical level, drand works as follows:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Setup Phase"}),":"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Participants generate BLS key pairs"}),"\n",(0,a.jsx)(n.li,{children:"Through a distributed key generation protocol, a group public key is created"}),"\n",(0,a.jsx)(n.li,{children:"Private key shares are distributed among participants"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Beacon Generation"}),":"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"For round 0, a signature on a specified message is created"}),"\n",(0,a.jsx)(n.li,{children:"For round n, a signature on H(prev_sig || round_number) is created"}),"\n",(0,a.jsx)(n.li,{children:"A threshold t of the n participants must contribute to create a valid signature"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Verification"}),":"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Anyone can verify the signature using the drand group public key"}),"\n",(0,a.jsx)(n.li,{children:"The deterministic message construction ensures only one valid signature exists per round"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"This creates a chain of linked, unpredictable, and verifiable random values."})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}}}]);