"use strict";(self.webpackChunksonic_red_dragon_docs=self.webpackChunksonic_red_dragon_docs||[]).push([[8264],{183:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>p,frontMatter:()=>s,metadata:()=>r,toc:()=>o});const r=JSON.parse('{"id":"contracts/jackpot/trigger","title":"Swap Trigger Oracle","description":"Lottery entry system based on token swap events with probability-based selection","source":"@site/docs/contracts/jackpot/trigger.md","sourceDirName":"contracts/jackpot","slug":"/contracts/jackpot/trigger","permalink":"/contracts/jackpot/trigger","draft":false,"unlisted":false,"editUrl":"https://github.com/wenakita/sonicreddragon-docs/edit/main/docs/contracts/jackpot/trigger.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"title":"Swap Trigger Oracle","description":"Lottery entry system based on token swap events with probability-based selection"},"sidebar":"contracts","previous":{"title":"DragonJackpotDistributor","permalink":"/contracts/jackpot/distributor"},"next":{"title":"Swap-Based Jackpot Trigger System","permalink":"/contracts/jackpot/triggers"}}');var a=i(4848),t=i(8453);const s={sidebar_position:3,title:"Swap Trigger Oracle",description:"Lottery entry system based on token swap events with probability-based selection"},l="OmniDragonSwapTriggerOracle",c={},o=[{value:"Overview",id:"overview",level:2},{value:"Contract Implementation",id:"contract-implementation",level:2},{value:"Core Functions",id:"core-functions",level:2},{value:"Lottery Entry Processing",id:"lottery-entry-processing",level:3},{value:"Probability Calculation",id:"probability-calculation",level:3},{value:"Oracle Price Aggregation",id:"oracle-price-aggregation",level:3},{value:"Oracle Integration",id:"oracle-integration",level:2},{value:"Anti-Abuse Mechanisms",id:"anti-abuse-mechanisms",level:2},{value:"Probability Curve",id:"probability-curve",level:2},{value:"Configuration Parameters",id:"configuration-parameters",level:2},{value:"Events",id:"events",level:2},{value:"Lottery Flow",id:"lottery-flow",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"omnidragonswaptriggeroracle",children:"OmniDragonSwapTriggerOracle"})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"OmniDragonSwapTriggerOracle"})," is a critical component of the OmniDragon lottery system. It processes swap events, assigns lottery entry probabilities, and interacts with oracle price feeds to ensure fair and transparent jackpot entry opportunities."]}),"\n",(0,a.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,a.jsx)(n.mermaid,{value:'flowchart TB\n    OmniDragon["OmniDragon Token"] --\x3e|"Calls onSwap()"| SwapTrigger["OmniDragonSwapTriggerOracle"]\n    SwapTrigger --\x3e|"Entry Processing"| Lottery["Lottery System"]\n    PriceFeeds["Oracle Price Feeds"] --\x3e|"Market Data"| SwapTrigger\n    \n    subgraph "Price Oracles"\n        Chainlink["Chainlink"]\n        API3["API3"]\n        Band["Band Protocol"]\n        Pyth["Pyth Network"]\n        Stork["Stork Network"]\n    end\n    \n    Chainlink --\x3e PriceFeeds\n    API3 --\x3e PriceFeeds\n    Band --\x3e PriceFeeds\n    Pyth --\x3e PriceFeeds\n    Stork --\x3e PriceFeeds\n    \n    class SwapTrigger highlight'}),"\n",(0,a.jsx)(n.p,{children:"The swap trigger oracle serves multiple key functions:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Lottery Entry Detection"}),": Processes swap events from the OmniDragon token"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Probability Calculation"}),": Determines each entry's win probability based on swap amount"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Oracle Integration"}),": Aggregates price data from multiple oracles for reliability"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Anti-Abuse Protection"}),": Implements safeguards against system manipulation"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Event Emission"}),": Emits events for off-chain lottery winner selection"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"contract-implementation",children:"Contract Implementation"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"OmniDragonSwapTriggerOracle"})," is implemented as follows:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-solidity",children:"contract OmniDragonSwapTriggerOracle is IOmniDragonSwapTriggerOracle, Ownable, ReentrancyGuard {\n    address public immutable omniDragon;\n    address public jackpotVault;\n    uint256 public minSwapAmount;\n    uint256 public cooldownPeriod; // in seconds\n    \n    // Oracle configuration\n    enum OracleType { CHAINLINK, API3, BAND, PYTH, REDSTONE, STORK }\n    \n    struct OracleSource {\n        address oracleAddress;\n        OracleType oracleType;\n        bool isActive;\n        uint8 decimals;\n    }\n    \n    // Multiple oracle data sources\n    mapping(uint8 => OracleSource) public oracleSources;\n    uint8 public activeOracleCount;\n    uint8 public minimumOracleResponses = 1; // Minimum oracles needed for valid price\n    \n    // Base probability configurations (in basis points, 10000 = 100%)\n    uint256 public baseWinProbability = 100; // 1% base chance\n    uint256 public maxWinProbability = 1000; // 10% max chance\n    \n    // Historical swap data for probability calculation\n    uint256 public totalSwapVolume;\n    uint256 public swapCount;\n    uint256 public averageSwapAmount;\n    \n    // Track user probability history\n    mapping(address => uint256) public userWinProbability;\n    mapping(address => uint256) public lastEntry;\n    \n    // ... events and modifiers ...\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"core-functions",children:"Core Functions"}),"\n",(0,a.jsx)(n.h3,{id:"lottery-entry-processing",children:"Lottery Entry Processing"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-solidity",children:'function onSwap(address user, uint256 amount) external override onlyOmniDragon nonReentrant {\n    require(user != address(0), "Zero user");\n    require(amount >= minSwapAmount, "Swap too small");\n    require(block.timestamp >= lastEntry[user] + cooldownPeriod, "Cooldown active");\n\n    // Calculate win probability for this swap\n    uint256 probability = calculateWinProbability(amount);\n    \n    // Update user\'s recorded probability\n    userWinProbability[user] = probability;\n    \n    // Update statistics for future calculations\n    _updateSwapStatistics(amount);\n    \n    // Record entry time\n    lastEntry[user] = block.timestamp;\n\n    emit LotteryEntry(user, amount, block.timestamp, probability);\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"This is the main entry point called by the OmniDragon token when a token swap occurs. It:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Validates minimum swap amount and cooldown period"}),"\n",(0,a.jsx)(n.li,{children:"Calculates win probability"}),"\n",(0,a.jsx)(n.li,{children:"Updates user statistics"}),"\n",(0,a.jsx)(n.li,{children:"Records the entry time"}),"\n",(0,a.jsx)(n.li,{children:"Emits an event for off-chain tracking"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"probability-calculation",children:"Probability Calculation"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-solidity",children:"function calculateWinProbability(uint256 amount) public view returns (uint256) {\n    // If we don't have enough data yet, return base probability\n    if (swapCount < 10 || averageSwapAmount == 0) {\n        return baseWinProbability;\n    }\n    \n    // Get aggregated price from oracles\n    (int256 price, bool priceSuccess) = getAggregatedPrice();\n    \n    // If price aggregation failed, use base probability\n    if (!priceSuccess || price <= 0) {\n        return baseWinProbability;\n    }\n    \n    // Calculate ratio of this swap to average (scaled by 10000)\n    uint256 swapRatio = (amount * 10000) / averageSwapAmount;\n    \n    // Calculate probability with logarithmic scaling\n    uint256 probability;\n    \n    if (swapRatio <= 10000) {\n        // For swaps below average, linear scale between base and 2x base\n        probability = baseWinProbability + ((baseWinProbability * swapRatio) / 10000);\n    } else {\n        // For swaps above average, logarithmic scale with diminishing returns\n        uint256 logFactor = 10000 * (1 + _log2(swapRatio / 10000));\n        probability = baseWinProbability + (baseWinProbability * logFactor) / 10000;\n    }\n    \n    // Cap at maximum probability\n    return probability > maxWinProbability ? maxWinProbability : probability;\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"This sophisticated probability algorithm ensures:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Larger swaps get higher probability (but not disproportionate)"}),"\n",(0,a.jsx)(n.li,{children:"A logarithmic curve is used for fair scaling"}),"\n",(0,a.jsx)(n.li,{children:"The probability is capped at a maximum value (10%)"}),"\n",(0,a.jsx)(n.li,{children:"Market conditions are factored in through oracle price data"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"oracle-price-aggregation",children:"Oracle Price Aggregation"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-solidity",children:"function getAggregatedPrice() public view returns (int256 aggregatedPrice, bool success) {\n    int256[] memory prices = new int256[](activeOracleCount);\n    uint8 validPrices = 0;\n    \n    // Collect prices from all active oracles\n    for (uint8 i = 0; i < 10; i++) {\n        if (oracleSources[i].isActive) {\n            (int256 price, bool priceSuccess) = getPriceFromOracle(i);\n            \n            if (priceSuccess && price > 0) {\n                prices[validPrices] = price;\n                validPrices++;\n            }\n        }\n    }\n    \n    // Check if we have enough valid prices\n    if (validPrices < minimumOracleResponses) {\n        return (0, false);\n    }\n    \n    // Sort prices to find median\n    // ... [sorting code omitted] ...\n    \n    // Calculate median price\n    if (validPrices % 2 == 0) {\n        // Even number of prices, average the middle two\n        aggregatedPrice = (prices[validPrices / 2 - 1] + prices[validPrices / 2]) / 2;\n    } else {\n        // Odd number of prices, take the middle one\n        aggregatedPrice = prices[validPrices / 2];\n    }\n    \n    return (aggregatedPrice, true);\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"This function provides reliable price data by:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Collecting prices from multiple oracle sources"}),"\n",(0,a.jsx)(n.li,{children:"Using a median calculation to prevent manipulation"}),"\n",(0,a.jsx)(n.li,{children:"Requiring a minimum number of valid responses"}),"\n",(0,a.jsx)(n.li,{children:"Normalizing different decimal formats"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"oracle-integration",children:"Oracle Integration"}),"\n",(0,a.jsx)(n.p,{children:"The contract can integrate with multiple price oracle providers:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-solidity",children:"// Oracle addresses\naddress public constant CHAINLINK_FEED = 0xc76dFb89fF298145b417d221B2c747d84952e01d;\naddress public constant API3_FEED = 0x709944a48cAf83535e43471680fDA4905FB3920a;\naddress public constant BAND_FEED = 0x506085050Ea5494Fe4b89Dd5BEa659F506F470Cc;\naddress public constant PYTH_FEED = 0x2880aB155794e7179c9eE2e38200202908C17B43;\naddress public constant STORK_FEED = 0xacC0a0cF13571d30B4b8637996F5D6D774d4fd62;\n"})}),"\n",(0,a.jsx)(n.p,{children:"Each oracle is represented with a standard structure:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-solidity",children:"struct OracleSource {\n    address oracleAddress;\n    OracleType oracleType;\n    bool isActive;\n    uint8 decimals;\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"Oracles can be added, updated, or disabled through owner-only management functions:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-solidity",children:'function addOracle(\n    uint8 _oracleId, \n    address _oracleAddress, \n    OracleType _oracleType,\n    uint8 _decimals\n) external onlyOwner {\n    _addOracle(_oracleId, _oracleAddress, _oracleType, _decimals);\n}\n\nfunction updateOracleStatus(uint8 _oracleId, bool _isActive) external onlyOwner {\n    require(oracleSources[_oracleId].oracleAddress != address(0), "Oracle does not exist");\n    \n    if (oracleSources[_oracleId].isActive && !_isActive) {\n        activeOracleCount--;\n    } else if (!oracleSources[_oracleId].isActive && _isActive) {\n        activeOracleCount++;\n    }\n    \n    oracleSources[_oracleId].isActive = _isActive;\n    emit OracleUpdated(_oracleId, oracleSources[_oracleId].oracleAddress, _isActive);\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"anti-abuse-mechanisms",children:"Anti-Abuse Mechanisms"}),"\n",(0,a.jsx)(n.p,{children:"Several mechanisms are implemented to prevent system abuse:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Minimum Swap Amount"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-solidity",children:'require(amount >= minSwapAmount, "Swap too small");\n'})}),"\n",(0,a.jsx)(n.p,{children:"Prevents dust transactions from participating."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Cooldown Period"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-solidity",children:'require(block.timestamp >= lastEntry[user] + cooldownPeriod, "Cooldown active");\n'})}),"\n",(0,a.jsx)(n.p,{children:"Prevents rapid entry spamming by users."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Oracle Consensus"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-solidity",children:"if (validPrices < minimumOracleResponses) {\n    return (0, false);\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"Requires multiple oracle sources to agree."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Logarithmic Scaling"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-solidity",children:"uint256 logFactor = 10000 * (1 + _log2(swapRatio / 10000));\n"})}),"\n",(0,a.jsx)(n.p,{children:"Prevents large swaps from having disproportionate advantages."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Maximum Cap"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-solidity",children:"return probability > maxWinProbability ? maxWinProbability : probability;\n"})}),"\n",(0,a.jsx)(n.p,{children:"Limits the maximum win probability to a fair value."}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"probability-curve",children:"Probability Curve"}),"\n",(0,a.jsx)(n.p,{children:"The implemented probability curve creates a fair distribution:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Base Probability"}),": 1% (100 basis points)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Average Swap"}),": ~1.5% (150 basis points)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"2x Average Swap"}),": ~1.69% (169 basis points) - logarithmic scaling starts"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"5x Average Swap"}),": ~2.16% (216 basis points)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"10x Average Swap"}),": ~2.32% (232 basis points)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Maximum Probability"}),": 10% (1000 basis points) - hard cap"]}),"\n"]}),"\n",(0,a.jsx)(n.mermaid,{value:'xychart-beta\n    title "Win Probability vs. Swap Size"\n    x-axis "Swap Size (multiple of average)" [0.1, 0.5, 1, 2, 5, 10, 20, 50, 100]\n    y-axis "Win Probability (%)" 0 --\x3e 10\n    line [0.5, 0.75, 1, 1.69, 2.16, 2.32, 2.6, 3.0, 3.3]'}),"\n",(0,a.jsx)(n.h2,{id:"configuration-parameters",children:"Configuration Parameters"}),"\n",(0,a.jsx)(n.p,{children:"The system can be configured with these parameters:"}),"\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"Parameter"}),(0,a.jsx)(n.th,{children:"Description"}),(0,a.jsx)(n.th,{children:"Default"}),(0,a.jsx)(n.th,{children:"Range"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"minSwapAmount"})}),(0,a.jsx)(n.td,{children:"Minimum swap size"}),(0,a.jsx)(n.td,{children:"Configurable"}),(0,a.jsx)(n.td,{children:"> 0"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"cooldownPeriod"})}),(0,a.jsx)(n.td,{children:"User cooldown period"}),(0,a.jsx)(n.td,{children:"Configurable"}),(0,a.jsx)(n.td,{children:"> 0"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"baseWinProbability"})}),(0,a.jsx)(n.td,{children:"Base win probability"}),(0,a.jsx)(n.td,{children:"100 (1%)"}),(0,a.jsx)(n.td,{children:"0-9999"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"maxWinProbability"})}),(0,a.jsx)(n.td,{children:"Maximum win probability"}),(0,a.jsx)(n.td,{children:"1000 (10%)"}),(0,a.jsx)(n.td,{children:"1-10000"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"minimumOracleResponses"})}),(0,a.jsx)(n.td,{children:"Required oracle responses"}),(0,a.jsx)(n.td,{children:"1"}),(0,a.jsx)(n.td,{children:"1-activeOracleCount"})]})]})]}),"\n",(0,a.jsx)(n.h2,{id:"events",children:"Events"}),"\n",(0,a.jsx)(n.p,{children:"The contract emits several events for tracking and auditing:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-solidity",children:"event LotteryEntry(address indexed user, uint256 amount, uint256 timestamp, uint256 winProbability);\nevent JackpotVaultUpdated(address indexed oldVault, address indexed newVault);\nevent MinSwapAmountUpdated(uint256 oldAmount, uint256 newAmount);\nevent CooldownPeriodUpdated(uint256 oldPeriod, uint256 newPeriod);\nevent OracleAdded(uint8 indexed oracleId, address oracleAddress, OracleType oracleType);\nevent OracleUpdated(uint8 indexed oracleId, address oracleAddress, bool isActive);\nevent MinimumOracleResponsesUpdated(uint8 oldValue, uint8 newValue);\nevent ProbabilityConfigUpdated(uint256 baseProb, uint256 maxProb);\n"})}),"\n",(0,a.jsx)(n.h2,{id:"lottery-flow",children:"Lottery Flow"}),"\n",(0,a.jsx)(n.p,{children:"The jackpot entry process follows this sequence:"}),"\n",(0,a.jsx)(n.mermaid,{value:"sequenceDiagram\n    participant User\n    participant OmniDragon as OmniDragon Token\n    participant SwapOracle as SwapTriggerOracle\n    participant PriceOracles as Price Oracles\n    participant OffChain as Off-Chain System\n    \n    User->>+OmniDragon: Trade tokens\n    OmniDragon->>+SwapOracle: onSwap(user, amount)\n    \n    SwapOracle->>SwapOracle: Check minimum amount\n    SwapOracle->>SwapOracle: Check cooldown period\n    \n    SwapOracle->>+PriceOracles: getAggregatedPrice()\n    PriceOracles--\x3e>-SwapOracle: Return median price\n    \n    SwapOracle->>SwapOracle: Calculate win probability\n    SwapOracle->>SwapOracle: Update user statistics\n    \n    SwapOracle--\x3e>-OmniDragon: Return\n    OmniDragon--\x3e>-User: Complete trade\n    \n    SwapOracle->>OffChain: Emit LotteryEntry event\n    Note over OffChain: Monitor events & select winners"})]})}function p(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>l});var r=i(6540);const a={},t=r.createContext(a);function s(e){const n=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);