"use strict";(self.webpackChunksonic_red_dragon_docs=self.webpackChunksonic_red_dragon_docs||[]).push([[7515],{5442:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>o,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"concepts/jackpot","title":"Jackpot System","description":"The OmniDragon Jackpot System is a core feature that distributes rewards to token holders based on verifiable randomness. This document explains how the system works and its key components.","source":"@site/docs/concepts/jackpot.md","sourceDirName":"concepts","slug":"/concepts/jackpot","permalink":"/concepts/jackpot","draft":false,"unlisted":false,"editUrl":"https://github.com/wenakita/sonicreddragon-docs/edit/main/docs/concepts/jackpot.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"title":"Jackpot System","sidebar_position":4},"sidebar":"concepts","previous":{"title":"Randomness System","permalink":"/concepts/randomness"}}');var s=t(4848),i=t(8453);const o={title:"Jackpot System",sidebar_position:4},a="OmniDragon Jackpot System",c={},l=[{value:"System Overview",id:"system-overview",level:2},{value:"Jackpot Cycle",id:"jackpot-cycle",level:2},{value:"Trigger Mechanism",id:"trigger-mechanism",level:2},{value:"Implementation Architecture",id:"implementation-architecture",level:2},{value:"Jackpot Distribution Formula",id:"jackpot-distribution-formula",level:2}];function d(e){const n={h1:"h1",h2:"h2",header:"header",li:"li",mermaid:"mermaid",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"omnidragon-jackpot-system",children:"OmniDragon Jackpot System"})}),"\n",(0,s.jsx)(n.p,{children:"The OmniDragon Jackpot System is a core feature that distributes rewards to token holders based on verifiable randomness. This document explains how the system works and its key components."}),"\n",(0,s.jsx)(n.h2,{id:"system-overview",children:"System Overview"}),"\n",(0,s.jsx)(n.p,{children:"The jackpot system uses a combination of fee collection, randomness, and distribution mechanisms to create an engaging token economy:"}),"\n",(0,s.jsx)(n.mermaid,{value:'flowchart TB\n    %% Define main components with clear labels\n    subgraph Collection ["Fee Collection"]\n        direction LR\n        TXFEE["Transaction Fees"]:::fee\n        BRIDGE["Bridge Fees"]:::fee\n        FEE_ADAPT["Adaptive Fee Logic"]:::fee\n    end\n    \n    subgraph Pool ["Jackpot Pool"]\n        direction TB\n        VAULT["Jackpot Vault"]:::vault\n        TRACKER["Growth Tracker"]:::vault\n    end\n    \n    subgraph Trigger ["Trigger Mechanism"]\n        direction LR\n        TIME["Time-Based"]:::trigger\n        RANDOM["Randomness Oracle"]:::trigger\n        THRESHOLD["Threshold Events"]:::trigger\n    end\n    \n    subgraph Distribution ["Reward Distribution"]\n        direction LR\n        WINNERS["Winner Selection"]:::dist\n        REWARDS["Reward Calculation"]:::dist\n        PAYOUT["Payout Process"]:::dist\n    end\n    \n    %% Connect the components\n    TXFEE --\x3e FEE_ADAPT\n    BRIDGE --\x3e FEE_ADAPT\n    FEE_ADAPT --\x3e VAULT\n    \n    VAULT --\x3e TRACKER\n    TRACKER --\x3e THRESHOLD\n    \n    TIME --\x3e RANDOM\n    RANDOM --\x3e WINNERS\n    THRESHOLD --\x3e WINNERS\n    \n    VAULT --\x3e REWARDS\n    WINNERS --\x3e REWARDS\n    REWARDS --\x3e PAYOUT\n    \n    %% Apply styling\n    classDef fee fill:#e3f2fd,stroke:#2196f3,color:#0d47a1\n    classDef vault fill:#e8f5e9,stroke:#4caf50,color:#1b5e20\n    classDef trigger fill:#fff8e1,stroke:#ffc107,color:#ff6f00\n    classDef dist fill:#f3e5f5,stroke:#9c27b0,color:#4a148c\n    \n    %% Style subgraphs\n    style Collection fill:#e3f2fd,stroke:#bbdefb,color:#0d47a1\n    style Pool fill:#e8f5e9,stroke:#c8e6c9,color:#1b5e20\n    style Trigger fill:#fff8e1,stroke:#ffecb3,color:#ff6f00\n    style Distribution fill:#f3e5f5,stroke:#e1bee7,color:#4a148c'}),"\n",(0,s.jsx)(n.h2,{id:"jackpot-cycle",children:"Jackpot Cycle"}),"\n",(0,s.jsx)(n.p,{children:"The jackpot system follows a regular cycle of accumulation, triggering, and distribution:"}),"\n",(0,s.jsx)(n.mermaid,{value:"flowchart LR\n    %% Define cycle stages\n    COLLECT([Fee Collection]):::collect\n    ACCUMULATE([Pool Growth]):::accumulate\n    TRIGGER([Trigger Event]):::trigger\n    SELECT([Winner Selection]):::select\n    DISTRIBUTE([Distribution]):::distribute\n    RESET([Pool Reset]):::reset\n    \n    %% Connect in cycle\n    COLLECT --\x3e ACCUMULATE\n    ACCUMULATE --\x3e TRIGGER\n    TRIGGER --\x3e SELECT\n    SELECT --\x3e DISTRIBUTE\n    DISTRIBUTE --\x3e RESET\n    RESET --\x3e COLLECT\n    \n    %% Apply styling\n    classDef collect fill:#e3f2fd,stroke:#2196f3,color:#0d47a1\n    classDef accumulate fill:#e8f5e9,stroke:#4caf50,color:#1b5e20\n    classDef trigger fill:#fff8e1,stroke:#ffc107,color:#ff6f00\n    classDef select fill:#f3e5f5,stroke:#9c27b0,color:#4a148c\n    classDef distribute fill:#fce4ec,stroke:#e91e63,color:#880e4f\n    classDef reset fill:#f5f5f5,stroke:#9e9e9e,color:#212121"}),"\n",(0,s.jsx)(n.h2,{id:"trigger-mechanism",children:"Trigger Mechanism"}),"\n",(0,s.jsx)(n.p,{children:"The jackpot is triggered through a combination of time-based and randomness-based mechanisms:"}),"\n",(0,s.jsx)(n.mermaid,{value:"sequenceDiagram\n    participant Timer as Time Oracle\n    participant VRF as Randomness Oracle\n    participant Trigger as Jackpot Trigger\n    participant Vault as Jackpot Vault\n    participant Distributor as Reward Distributor\n    \n    %% Add style regions\n    rect rgb(238, 242, 255)\n    note over Timer,VRF: Conditions check\n    end\n    \n    Timer->>+Trigger: Time threshold reached\n    Trigger->>Trigger: Check eligibility\n    Trigger->>+VRF: Request trigger randomness\n    \n    rect rgb(255, 248, 225)\n    note over VRF,Trigger: Random determination\n    end\n    \n    VRF--\x3e>-Trigger: Provide randomness\n    Trigger->>Trigger: Determine if triggered\n    \n    alt Jackpot triggered\n        rect rgb(243, 229, 245)\n        note over Trigger,Distributor: Distribution process\n        end\n        \n        Trigger->>+Vault: Request current pool\n        Vault--\x3e>-Trigger: Return pool amount\n        Trigger->>+Distributor: Initiate distribution\n        Distributor->>+VRF: Request winner selection\n        VRF--\x3e>-Distributor: Provide selection randomness\n        Distributor->>Distributor: Select winners\n        Distributor->>Distributor: Calculate rewards\n        Distributor->>Vault: Transfer rewards\n        Distributor--\x3e>-Trigger: Distribution complete\n    else Not triggered\n        Trigger->>Trigger: Update next check time\n    end\n    \n    Trigger--\x3e>-Timer: Process complete"}),"\n",(0,s.jsx)(n.h2,{id:"implementation-architecture",children:"Implementation Architecture"}),"\n",(0,s.jsx)(n.p,{children:"The core contracts that implement the jackpot system are structured as follows:"}),"\n",(0,s.jsx)(n.mermaid,{value:"classDiagram\n    %% Define core contracts\n    class JackpotVault {\n        -uint256 poolAmount\n        -address trigger\n        -address distributor\n        +deposit(uint256 amount)\n        +withdraw(address recipient, uint256 amount)\n        +getPoolSize() uint256\n    }\n    \n    class JackpotTrigger {\n        -address vault\n        -address randomness\n        -uint256 minTime\n        -uint256 lastCheck\n        +checkTrigger() bool\n        +executeTrigger()\n        +setParameters(uint256 minTime)\n    }\n    \n    class RewardDistributor {\n        -address vault\n        -address randomness\n        -uint256 winnersCount\n        +distributeRewards()\n        +selectWinners() address[]\n        +calculateRewards(address[] winners) uint256[]\n    }\n    \n    class RandomnessConsumer {\n        -address vrfCoordinator\n        +requestRandomness() bytes32\n        +fulfillRandomness(bytes32 requestId, uint256 randomness)\n    }\n    \n    class FeeCollector {\n        -address vault\n        -uint256 feeRate\n        +collectFee(uint256 amount) uint256\n        +setFeeRate(uint256 rate)\n    }\n    \n    %% Define relationships\n    FeeCollector --\x3e JackpotVault: deposits fees\n    JackpotTrigger --\x3e JackpotVault: requests pool\n    JackpotTrigger --\x3e RandomnessConsumer: requests randomness\n    JackpotTrigger --\x3e RewardDistributor: initiates distribution\n    RewardDistributor --\x3e JackpotVault: withdraws rewards\n    RewardDistributor --\x3e RandomnessConsumer: requests randomness\n    \n    %% Apply styling\n    classDef vault fill:#e8f5e9,stroke:#4caf50,color:#1b5e20\n    classDef trigger fill:#fff8e1,stroke:#ffc107,color:#ff6f00\n    classDef distributor fill:#f3e5f5,stroke:#9c27b0,color:#4a148c\n    classDef randomness fill:#e0f7fa,stroke:#00bcd4,color:#006064\n    classDef fee fill:#e3f2fd,stroke:#2196f3,color:#0d47a1\n    \n    class JackpotVault vault\n    class JackpotTrigger trigger\n    class RewardDistributor distributor\n    class RandomnessConsumer randomness\n    class FeeCollector fee"}),"\n",(0,s.jsx)(n.h2,{id:"jackpot-distribution-formula",children:"Jackpot Distribution Formula"}),"\n",(0,s.jsx)(n.p,{children:"The jackpot distribution uses a weighted formula that rewards both loyalty and token holdings:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Base Allocation"}),": 60% of the pool distributed to randomly selected winners"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Staking Boost"}),": 30% additional weight for staked tokens"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Loyalty Multiplier"}),": Up to 2x multiplier based on holding duration"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Cross-Chain Participants"}),": Special allocation for cross-chain token holders"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"This creates an engaging and fair distribution system that incentivizes long-term holding and active participation in the OmniDragon ecosystem."})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var r=t(6540);const s={},i=r.createContext(s);function o(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);