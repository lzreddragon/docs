"use strict";(self.webpackChunksonic_red_dragon_docs=self.webpackChunksonic_red_dragon_docs||[]).push([[2200],{4354:(n,e,s)=>{s.r(e),s.d(e,{assets:()=>d,contentTitle:()=>o,default:()=>c,frontMatter:()=>a,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"concepts/randomness-fixed","title":"Secure Randomness System","description":"The OmniDragon protocol incorporates a robust multi-source randomness system to ensure fair and unpredictable outcomes for jackpot distributions and other protocol operations.","source":"@site/docs/concepts/randomness-fixed.md","sourceDirName":"concepts","slug":"/concepts/randomness-fixed","permalink":"/concepts/randomness-fixed","draft":false,"unlisted":false,"editUrl":"https://github.com/wenakita/sonicreddragon-docs/edit/main/docs/concepts/randomness-fixed.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5,"title":"Secure Randomness System"}}');var i=s(4848),t=s(8453);const a={sidebar_position:5,title:"Secure Randomness System"},o="Secure Randomness System",d={},l=[{value:"Randomness Architecture",id:"randomness-architecture",level:2},{value:"Randomness Sources",id:"randomness-sources",level:2},{value:"Chainlink VRF",id:"chainlink-vrf",level:3},{value:"Drand Network",id:"drand-network",level:3},{value:"Arbitrum VRF",id:"arbitrum-vrf",level:3},{value:"Internal PRNG",id:"internal-prng",level:3},{value:"Randomness Flow",id:"randomness-flow",level:2},{value:"Randomness Security Measures",id:"randomness-security-measures",level:2},{value:"Multi-Source Aggregation",id:"multi-source-aggregation",level:3},{value:"Source Verification",id:"source-verification",level:3},{value:"Fallback Mechanisms",id:"fallback-mechanisms",level:3},{value:"Implementation Details",id:"implementation-details",level:2},{value:"Randomness Consumers",id:"randomness-consumers",level:2},{value:"Jackpot Trigger System",id:"jackpot-trigger-system",level:3},{value:"Winner Selection",id:"winner-selection",level:3},{value:"Cross-Chain Randomness",id:"cross-chain-randomness",level:2},{value:"Key Features",id:"key-features",level:2},{value:"Integration Examples",id:"integration-examples",level:2}];function u(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,t.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"secure-randomness-system",children:"Secure Randomness System"})}),"\n",(0,i.jsx)(e.p,{children:"The OmniDragon protocol incorporates a robust multi-source randomness system to ensure fair and unpredictable outcomes for jackpot distributions and other protocol operations."}),"\n",(0,i.jsx)(e.h2,{id:"randomness-architecture",children:"Randomness Architecture"}),"\n",(0,i.jsx)(e.p,{children:"The protocol implements a layered architecture for randomness generation:"}),"\n",(0,i.jsx)(e.mermaid,{value:'flowchart TB\n    %% Define main components\n    subgraph CoreRNG ["Core Randomness Components"]\n        direction TB\n        INTERFACE["IRandomnessConsumer"]:::interface\n        AGGREGATOR["RandomnessAggregator"]:::core\n        FALLBACK["FallbackSystem"]:::core\n    end\n    \n    subgraph Sources ["Randomness Sources"]\n        direction LR\n        CHAINLINK["Chainlink VRF"]:::source\n        DRAND["Drand Network"]:::source\n        ARB_VRF["Arbitrum VRF"]:::source\n        INTERNAL["Internal PRNG"]:::source\n    end\n    \n    subgraph Consumers ["Randomness Consumers"]\n        direction LR\n        JACKPOT["Jackpot System"]:::consumer\n        TRIGGER["Trigger System"]:::consumer\n        SELECTION["Winner Selection"]:::consumer\n        LOTTERY["Lottery System"]:::consumer\n    end\n    \n    %% Connect the systems\n    Sources --\x3e|"Provide seeds"| AGGREGATOR\n    INTERFACE -.->|"Implemented by"| Consumers\n    AGGREGATOR --\x3e|"Provides randomness"| Consumers\n    FALLBACK --\x3e|"Backup mechanism"| AGGREGATOR\n    \n    %% Apply styling\n    classDef interface fill:#e3f2fd,stroke:#1e88e5,color:#0d47a1\n    classDef core fill:#e8f5e9,stroke:#43a047,color:#1b5e20\n    classDef source fill:#f3e5f5,stroke:#8e24aa,color:#4a148c\n    classDef consumer fill:#fff8e1,stroke:#ffb300,color:#ff6f00\n    \n    %% Style subgraphs\n    style CoreRNG fill:#e3f2fd,stroke:#bbdefb,color:#1565c0\n    style Sources fill:#f3e5f5,stroke:#e1bee7,color:#6a1b9a\n    style Consumers fill:#fff8e1,stroke:#ffecb3,color:#ff8f00'}),"\n",(0,i.jsx)(e.h2,{id:"randomness-sources",children:"Randomness Sources"}),"\n",(0,i.jsx)(e.p,{children:"OmniDragon leverages multiple randomness sources to ensure reliability and unpredictability:"}),"\n",(0,i.jsx)(e.h3,{id:"chainlink-vrf",children:"Chainlink VRF"}),"\n",(0,i.jsx)(e.p,{children:"Chainlink's Verifiable Random Function (VRF) provides cryptographically secure randomness that can be verified on-chain:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-solidity",children:"function requestRandomnessFromChainlink() internal returns (uint256 requestId) {\n    return vrfCoordinator.requestRandomWords(\n        keyHash,\n        subscriptionId,\n        requestConfirmations,\n        callbackGasLimit,\n        1 // Number of random words\n    );\n}\n\nfunction fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) \n    internal override \n{\n    // Process the received randomness\n    uint256 randomValue = randomWords[0];\n    \n    // Store or use the random value\n    emit RandomnessReceived(requestId, randomValue);\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"drand-network",children:"Drand Network"}),"\n",(0,i.jsx)(e.p,{children:"The Drand network provides publicly verifiable, unbiased, and unpredictable randomness:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-solidity",children:'function verifyAndUseDrandRandomness(\n    uint256 roundNumber,\n    bytes calldata signature,\n    bytes calldata previousSignature\n) external onlyOracle returns (bytes32 randomness) {\n    // Verify signature with drand public key\n    require(drandVerifier.verify(roundNumber, signature, previousSignature), \n        "Invalid drand proof");\n    \n    // Extract randomness from signature\n    randomness = keccak256(signature);\n    \n    // Use the randomness\n    emit DrandRandomnessReceived(roundNumber, randomness);\n    return randomness;\n}\n'})}),"\n",(0,i.jsx)(e.h3,{id:"arbitrum-vrf",children:"Arbitrum VRF"}),"\n",(0,i.jsx)(e.p,{children:"Arbitrum's native VRF provides randomness specifically optimized for the Arbitrum chain:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-solidity",children:"function requestArbitrumRandomness() internal returns (uint256 requestId) {\n    return arbitrumVRF.requestRandomWords(callbackGasLimit, 1);\n}\n\nfunction fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) \n    internal override \n{\n    // Process the received randomness\n    uint256 randomValue = randomWords[0];\n    \n    // Store or use the random value\n    emit ArbitrumRandomnessReceived(requestId, randomValue);\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"internal-prng",children:"Internal PRNG"}),"\n",(0,i.jsx)(e.p,{children:"As a fallback mechanism, an internal pseudo-random number generator combines on-chain data:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-solidity",children:"function generateFallbackRandomness() internal view returns (uint256) {\n    return uint256(keccak256(abi.encodePacked(\n        blockhash(block.number - 1),\n        block.timestamp,\n        msg.sender,\n        address(this),\n        randomnessSeed\n    )));\n}\n"})}),"\n",(0,i.jsx)(e.h2,{id:"randomness-flow",children:"Randomness Flow"}),"\n",(0,i.jsx)(e.p,{children:"The process of requesting and receiving randomness follows this sequence:"}),"\n",(0,i.jsx)(e.mermaid,{value:"sequenceDiagram\n    participant Consumer as Randomness Consumer\n    participant Aggregator as Randomness Aggregator\n    participant Chainlink as Chainlink VRF\n    participant Drand as Drand Network\n    participant Arbitrum as Arbitrum VRF\n    \n    %% Style regions\n    rect rgb(233, 245, 255)\n    note over Consumer,Aggregator: Request Phase\n    end\n    \n    Consumer->>+Aggregator: requestRandomness()\n    Aggregator->>Aggregator: Generate requestId\n    \n    alt Primary Source (Chainlink)\n        Aggregator->>+Chainlink: requestRandomWords()\n        Chainlink--\x3e>-Aggregator: Chainlink requestId\n        Aggregator->>Aggregator: Map requestIds\n    else Secondary Source (Drand)\n        Aggregator->>+Drand: Request via oracle\n        Drand--\x3e>-Aggregator: Pending (off-chain)\n    else Tertiary Source (Arbitrum VRF)\n        Aggregator->>+Arbitrum: requestRandomWords()\n        Arbitrum--\x3e>-Aggregator: Arbitrum requestId\n    end\n    \n    Aggregator--\x3e>-Consumer: OmniDragon requestId\n    \n    rect rgb(245, 235, 255)\n    note over Aggregator: Fulfillment Phase\n    end\n    \n    alt Chainlink Fulfillment\n        Chainlink->>+Aggregator: fulfillRandomWords(requestId, randomWords)\n        Aggregator->>Aggregator: Store Chainlink randomness\n    else Drand Fulfillment\n        Drand->>+Aggregator: fulfillDrandRandomness(roundNumber, signature)\n        Aggregator->>Aggregator: Verify and store Drand randomness\n    else Arbitrum Fulfillment\n        Arbitrum->>+Aggregator: fulfillRandomWords(requestId, randomWords)\n        Aggregator->>Aggregator: Store Arbitrum randomness\n    end\n    \n    rect rgb(242, 255, 235)\n    note over Consumer,Aggregator: Consumption Phase\n    end\n    \n    Aggregator->>Aggregator: Combine randomness from sources\n    Aggregator->>+Consumer: fulfillRandomness(requestId, randomValue)\n    Consumer->>Consumer: Process randomness\n    Consumer--\x3e>-Aggregator: Randomness consumed"}),"\n",(0,i.jsx)(e.h2,{id:"randomness-security-measures",children:"Randomness Security Measures"}),"\n",(0,i.jsx)(e.p,{children:"The OmniDragon randomness system implements several security measures:"}),"\n",(0,i.jsx)(e.h3,{id:"multi-source-aggregation",children:"Multi-Source Aggregation"}),"\n",(0,i.jsx)(e.p,{children:"Randomness is derived from multiple independent sources to prevent single points of failure:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-solidity",children:"function aggregateRandomness(\n    uint256 chainlinkRandom,\n    bytes32 drandRandom,\n    uint256 arbitrumRandom\n) internal pure returns (uint256) {\n    return uint256(keccak256(abi.encodePacked(\n        chainlinkRandom,\n        drandRandom,\n        arbitrumRandom\n    )));\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"source-verification",children:"Source Verification"}),"\n",(0,i.jsx)(e.p,{children:"Each randomness source is verified for authenticity:"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Chainlink VRF"}),": Uses cryptographic verification built into the VRF"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Drand"}),": Verifies threshold signatures against the Drand public key"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Arbitrum VRF"}),": Verifies the randomness comes from the Arbitrum VRF system"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"fallback-mechanisms",children:"Fallback Mechanisms"}),"\n",(0,i.jsx)(e.p,{children:"If primary randomness sources fail, the system falls back to alternative sources:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-solidity",children:'function getRandomness(uint256 requestId) external view returns (uint256) {\n    RandomnessRequest storage request = requests[requestId];\n    \n    // Try primary source\n    if (request.chainlinkFulfilled) {\n        return request.chainlinkRandomness;\n    }\n    \n    // Try secondary source\n    if (request.drandFulfilled) {\n        return uint256(request.drandRandomness);\n    }\n    \n    // Try tertiary source\n    if (request.arbitrumFulfilled) {\n        return request.arbitrumRandomness;\n    }\n    \n    // Use fallback if all else fails and enough time has passed\n    if (block.timestamp >= request.timestamp + FALLBACK_TIMEOUT) {\n        return generateFallbackRandomness();\n    }\n    \n    revert("Randomness not yet available");\n}\n'})}),"\n",(0,i.jsx)(e.h2,{id:"implementation-details",children:"Implementation Details"}),"\n",(0,i.jsx)(e.mermaid,{value:"classDiagram\n    %% Define interfaces\n    class IRandomnessConsumer {\n        <<interface>>\n        +fulfillRandomness(uint256 requestId, uint256 randomness)\n    }\n    \n    class IRandomnessProvider {\n        <<interface>>\n        +requestRandomness() uint256\n        +getRandomness(uint256 requestId) uint256\n    }\n    \n    %% Define core components\n    class RandomnessAggregator {\n        -mapping(uint256 => RandomnessRequest) requests\n        -uint256 requestCounter\n        -address chainlinkCoordinator\n        -address drandVerifier\n        -address arbitrumVRF\n        +requestRandomness() uint256\n        +fulfillChainlinkRandomness(uint256, uint256[])\n        +fulfillDrandRandomness(uint256, bytes, bytes)\n        +fulfillArbitrumRandomness(uint256, uint256[])\n        +getRandomness(uint256) uint256\n        -aggregateRandomness(uint256, bytes32, uint256) uint256\n    }\n    \n    class ChainlinkConsumer {\n        -address vrfCoordinator\n        -bytes32 keyHash\n        -uint64 subscriptionId\n        +requestRandomWords() uint256\n        +fulfillRandomWords(uint256, uint256[])\n    }\n    \n    class DrandConsumer {\n        -address drandVerifier\n        -address drandOracle\n        +verifyAndUseDrandRandomness(uint256, bytes, bytes) bytes32\n    }\n    \n    class ArbitrumVRFConsumer {\n        -address arbVRFCoordinator\n        +requestRandomWords() uint256\n        +fulfillRandomWords(uint256, uint256[])\n    }\n    \n    %% Define relationships\n    IRandomnessProvider <|.. RandomnessAggregator : implements\n    RandomnessAggregator *-- ChainlinkConsumer : uses\n    RandomnessAggregator *-- DrandConsumer : uses\n    RandomnessAggregator *-- ArbitrumVRFConsumer : uses\n    \n    %% Application consumers\n    class JackpotSystem {\n        -IRandomnessProvider randomnessProvider\n        +triggerJackpot() uint256\n        +fulfillRandomness(uint256, uint256)\n    }\n    \n    class WinnerSelection {\n        -IRandomnessProvider randomnessProvider\n        +selectWinners(uint256 count) uint256\n        +fulfillRandomness(uint256, uint256)\n    }\n    \n    IRandomnessConsumer <|.. JackpotSystem : implements\n    IRandomnessConsumer <|.. WinnerSelection : implements\n    \n    %% Apply styling\n    classDef interface fill:#e3f2fd,stroke:#1e88e5,color:#0d47a1\n    classDef core fill:#e8f5e9,stroke:#43a047,color:#1b5e20\n    classDef source fill:#f3e5f5,stroke:#8e24aa,color:#4a148c\n    classDef consumer fill:#fff8e1,stroke:#ffb300,color:#ff6f00\n    \n    class IRandomnessConsumer,IRandomnessProvider interface\n    class RandomnessAggregator core\n    class ChainlinkConsumer,DrandConsumer,ArbitrumVRFConsumer source\n    class JackpotSystem,WinnerSelection consumer"}),"\n",(0,i.jsx)(e.h2,{id:"randomness-consumers",children:"Randomness Consumers"}),"\n",(0,i.jsx)(e.p,{children:"Various components of the OmniDragon ecosystem consume randomness:"}),"\n",(0,i.jsx)(e.h3,{id:"jackpot-trigger-system",children:"Jackpot Trigger System"}),"\n",(0,i.jsx)(e.p,{children:"Uses randomness to determine when jackpots should be triggered:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-solidity",children:"function triggerJackpot() external onlyAuthorized returns (uint256) {\n    uint256 requestId = randomnessProvider.requestRandomness();\n    pendingRequests[requestId] = RequestType.TRIGGER;\n    return requestId;\n}\n\nfunction fulfillRandomness(uint256 requestId, uint256 randomness) external override onlyRandomnessProvider {\n    if (pendingRequests[requestId] == RequestType.TRIGGER) {\n        // Determine if jackpot should trigger based on randomness\n        bool shouldTrigger = randomness % 100 < triggerProbability;\n        \n        if (shouldTrigger) {\n            // Trigger jackpot distribution\n            jackpotDistributor.initiateDistribution();\n        }\n        \n        delete pendingRequests[requestId];\n        emit TriggerProcessed(requestId, randomness, shouldTrigger);\n    }\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"winner-selection",children:"Winner Selection"}),"\n",(0,i.jsx)(e.p,{children:"Uses randomness to select jackpot winners from eligible participants:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-solidity",children:"function selectWinners(uint256 count) external onlyAuthorized returns (uint256) {\n    uint256 requestId = randomnessProvider.requestRandomness();\n    winnerSelectionRequests[requestId] = WinnerRequest({\n        count: count,\n        processed: false\n    });\n    return requestId;\n}\n\nfunction fulfillRandomness(uint256 requestId, uint256 randomness) external override onlyRandomnessProvider {\n    WinnerRequest storage request = winnerSelectionRequests[requestId];\n    if (!request.processed) {\n        // Use randomness to select winners\n        address[] memory winners = selectWinnersUsingRandomness(randomness, request.count);\n        \n        // Process winners\n        jackpotDistributor.distributeToWinners(winners);\n        \n        request.processed = true;\n        emit WinnersSelected(requestId, winners);\n    }\n}\n\nfunction selectWinnersUsingRandomness(uint256 randomness, uint256 count) internal view returns (address[] memory) {\n    address[] memory eligibleParticipants = getEligibleParticipants();\n    uint256 participantCount = eligibleParticipants.length;\n    address[] memory selectedWinners = new address[](count);\n    \n    // Use randomness as seed\n    uint256 seed = randomness;\n    \n    for (uint256 i = 0; i < count && i < participantCount; i++) {\n        // Generate new random number for each selection\n        seed = uint256(keccak256(abi.encodePacked(seed, i)));\n        \n        // Select random index\n        uint256 index = seed % (participantCount - i);\n        \n        // Get winner at index\n        selectedWinners[i] = eligibleParticipants[index];\n        \n        // Swap selected participant with last unselected one\n        eligibleParticipants[index] = eligibleParticipants[participantCount - i - 1];\n    }\n    \n    return selectedWinners;\n}\n"})}),"\n",(0,i.jsx)(e.h2,{id:"cross-chain-randomness",children:"Cross-Chain Randomness"}),"\n",(0,i.jsx)(e.p,{children:"The OmniDragon protocol ensures consistent randomness across multiple chains:"}),"\n",(0,i.jsx)(e.mermaid,{value:"sequenceDiagram\n    participant Origin as Origin Chain\n    participant Bridge as LayerZero Bridge\n    participant Dest as Destination Chain\n    \n    Origin->>+Origin: Request randomness\n    Origin->>Origin: Receive randomness\n    Origin->>+Bridge: Send randomness to other chains\n    Bridge->>+Dest: Deliver randomness\n    Dest->>Dest: Verify and use randomness\n    Dest--\x3e>-Bridge: Acknowledge receipt\n    Bridge--\x3e>-Origin: Confirm delivery\n    Origin--\x3e>-Origin: Update cross-chain state"}),"\n",(0,i.jsx)(e.h2,{id:"key-features",children:"Key Features"}),"\n",(0,i.jsx)(e.p,{children:"The OmniDragon randomness system provides several important features:"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Unpredictability"}),": Multiple sources ensure truly unpredictable outcomes"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Reliability"}),": Fallback mechanisms prevent system failure"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Verifiability"}),": All randomness can be cryptographically verified"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Cross-Chain Consistency"}),": Same randomness used across all chains"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Modularity"}),": Easy to add new randomness sources or consumers"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Security"}),": Designed to resist manipulation attempts"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"integration-examples",children:"Integration Examples"}),"\n",(0,i.jsx)(e.p,{children:"Example of integrating with the randomness system:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-solidity",children:'// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport "@omnidragon/interfaces/IRandomnessConsumer.sol";\nimport "@omnidragon/interfaces/IRandomnessProvider.sol";\n\ncontract RandomnessExample is IRandomnessConsumer {\n    IRandomnessProvider public randomnessProvider;\n    \n    mapping(uint256 => bool) public pendingRequests;\n    uint256 public lastRandomValue;\n    \n    constructor(address _provider) {\n        randomnessProvider = IRandomnessProvider(_provider);\n    }\n    \n    function requestRandomNumber() external returns (uint256) {\n        uint256 requestId = randomnessProvider.requestRandomness();\n        pendingRequests[requestId] = true;\n        return requestId;\n    }\n    \n    function fulfillRandomness(uint256 requestId, uint256 randomness) external override {\n        require(msg.sender == address(randomnessProvider), "Only provider");\n        require(pendingRequests[requestId], "Unknown request");\n        \n        // Process randomness\n        lastRandomValue = randomness;\n        delete pendingRequests[requestId];\n        \n        // Use randomness in application logic\n        // ...\n    }\n}\n'})})]})}function c(n={}){const{wrapper:e}={...(0,t.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(u,{...n})}):u(n)}},8453:(n,e,s)=>{s.d(e,{R:()=>a,x:()=>o});var r=s(6540);const i={},t=r.createContext(i);function a(n){const e=r.useContext(t);return r.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:a(n.components),r.createElement(t.Provider,{value:e},n.children)}}}]);