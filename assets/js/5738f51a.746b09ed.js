"use strict";(self.webpackChunksonic_red_dragon_docs=self.webpackChunksonic_red_dragon_docs||[]).push([[2779],{2021:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>c,default:()=>m,frontMatter:()=>l,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"contracts/math/hermes-math","title":"HermesMath","description":"Proprietary jackpot distribution mathematics implementing the Herm\xe8s formula","source":"@site/docs/contracts/math/hermes-math.md","sourceDirName":"contracts/math","slug":"/contracts/math/hermes-math","permalink":"/contracts/math/hermes-math","draft":false,"unlisted":false,"editUrl":"https://github.com/wenakita/sonicreddragon-docs/edit/main/docs/contracts/math/hermes-math.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"title":"HermesMath","description":"Proprietary jackpot distribution mathematics implementing the Herm\xe8s formula"},"sidebar":"contracts","previous":{"title":"DragonMathLib","permalink":"/contracts/math/dragon-math-lib"},"next":{"title":"ve69LPMath","permalink":"/contracts/math/ve69lp-math"}}');var a=t(4848),r=t(8453),o=t(5537),s=t(9329);const l={sidebar_position:3,title:"HermesMath",description:"Proprietary jackpot distribution mathematics implementing the Herm\xe8s formula"},c="HermesMath",u={},d=[{value:"Overview",id:"overview",level:2},{value:"The Herm\xe8s Formula",id:"the-herm\xe8s-formula",level:2},{value:"Mathematical Expression",id:"mathematical-expression",level:3},{value:"Implementation",id:"implementation",level:3},{value:"Distribution Parameters",id:"distribution-parameters",level:2},{value:"Distribution Calculation",id:"distribution-calculation",level:2},{value:"Win Probability Calculation",id:"win-probability-calculation",level:2},{value:"Integration Examples",id:"integration-examples",level:2},{value:"Jackpot Distribution System",id:"jackpot-distribution-system",level:3},{value:"Mathematical Background",id:"mathematical-background",level:2},{value:"The Herm\xe8s Distribution Model",id:"the-herm\xe8s-distribution-model",level:3},{value:"Numerical Properties",id:"numerical-properties",level:3}];function p(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"hermesmath",children:"HermesMath"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Proprietary jackpot distribution mathematics implementing the Herm\xe8s formula"})}),"\n",(0,a.jsxs)("div",{className:"contract-badges",children:[(0,a.jsx)("span",{className:"contract-badge distribution",children:"Distribution System"}),(0,a.jsx)("span",{className:"contract-badge jackpot",children:"Jackpot Mathematics"}),(0,a.jsx)("span",{className:"contract-badge proprietary",children:"Proprietary Algorithm"})]}),"\n",(0,a.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,a.jsx)(n.p,{children:"The Herm\xe8s formula provides a mathematically balanced approach to jackpot distribution, optimizing for both large prize pools and frequent wins:"}),"\n",(0,a.jsx)(n.mermaid,{value:'flowchart TB\n    subgraph "Mathematical Components"\n        formula["Herm\xe8s Formula"]\n        comp1["Component 1<br>Approximation"]\n        comp2["Component 2<br>Approximation"]\n        cubeRoot["Cube Root<br>Approximation"]\n    end\n    \n    subgraph "Distribution Parameters"\n        jackpotBps["Jackpot Percentage"]\n        lpBps["LP Rewards"]\n        burnBps["Burn Allocation"]\n        winProb["Win Probability"]\n    end\n    \n    subgraph "Applications"\n        jackpotSize["Jackpot Size<br>Calculation"]\n        distribution["Reward<br>Distribution"]\n        probCalculation["Probability<br>Calculations"]\n    end\n    \n    formula --\x3e comp1\n    formula --\x3e comp2\n    comp1 --\x3e cubeRoot\n    cubeRoot --\x3e formula\n    \n    formula --\x3e jackpotSize\n    jackpotBps --\x3e distribution\n    lpBps --\x3e distribution\n    burnBps --\x3e distribution\n    winProb --\x3e probCalculation\n    \n    classDef highlight fill:#4a80d1,stroke:#333,stroke-width:2px,color:white\n    class formula highlight'}),"\n",(0,a.jsx)(n.h2,{id:"the-herm\xe8s-formula",children:"The Herm\xe8s Formula"}),"\n",(0,a.jsx)(n.p,{children:"The Herm\xe8s formula is a sophisticated mathematical model designed specifically for the OmniDragon jackpot system. It provides an optimal balance between jackpot growth and win frequency using a complex mathematical function."}),"\n",(0,a.jsx)(n.h3,{id:"mathematical-expression",children:"Mathematical Expression"}),"\n",(0,a.jsx)("div",{className:"math-formula",children:(0,a.jsx)(n.p,{children:"H(x) = \u221b(x\u2074 + d^(n+2)/(n\xb2 \xb7 x)) - x\xb2/(3 \xb7 \u221b(x\u2074 + d^(n+2)/(n\xb2 \xb7 x)))"})}),"\n",(0,a.jsx)(n.p,{children:"Where:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"x"})," is the current jackpot size"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"d"})," is protocol constant D (governance parameter)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"n"})," is protocol constant N (governance parameter)"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"implementation",children:"Implementation"}),"\n",(0,a.jsx)(n.p,{children:"Due to the complexity of this formula, the implementation uses approximations optimized for Solidity:"}),"\n",(0,a.jsxs)(o.A,{children:[(0,a.jsx)(s.A,{value:"main",label:"Main Function",default:!0,children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-solidity",children:"/**\n * @notice Calculate jackpot distribution using the Herm\xe8s formula\n * @param x Current jackpot size (scaled by 1e18)\n * @param d Protocol constant D (governance parameter)\n * @param n Protocol constant N (governance parameter)\n * @return Distribution value according to Herm\xe8s formula\n */\nfunction calculateHermesValue(uint256 x, uint256 d, uint256 n) internal pure returns (uint256) {\n    // Handle edge cases\n    if (x == 0) return 0;\n    \n    // Step 1: Calculate the component under the cube root\n    uint256 component1 = approximateComponent1(x, d, n);\n    \n    // Step 2: Calculate the cube root\n    uint256 cubeRoot = approximateCubeRoot(component1);\n    \n    // Step 3: Calculate the second component\n    uint256 component2 = approximateComponent2(x, cubeRoot);\n    \n    // Return the result (ensuring no underflow)\n    if (component2 >= cubeRoot) return 0;\n    return cubeRoot - component2;\n}\n"})})}),(0,a.jsx)(s.A,{value:"component1",label:"Component 1",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-solidity",children:"/**\n * @notice Approximate the first component of the Herm\xe8s formula\n * @param x Current jackpot size\n * @param d Protocol constant D\n * @param n Protocol constant N\n * @return Approximate value of the first component\n */\nfunction approximateComponent1(uint256 x, uint256 d, uint256 n) private pure returns (uint256) {\n    // Calculate x^4\n    uint256 x2 = (x * x) / PRECISION;\n    uint256 x4 = (x2 * x2) / PRECISION;\n    \n    // Calculate d^(n+2)\n    uint256 nPlus2 = n + 2 * PRECISION;\n    uint256 dTermExp = nPlus2 / PRECISION;\n    \n    uint256 dTerm = d;\n    for (uint256 i = 1; i < dTermExp; i++) {\n        dTerm = (dTerm * d) / PRECISION;\n    }\n    \n    // Calculate fractional part\n    uint256 nSquared = (n * n) / PRECISION;\n    uint256 denominator = (nSquared * x) / PRECISION;\n    \n    // Calculate final result: x^4 + d^(n+2)/(n^2*x)\n    uint256 result = x4;\n    \n    // Safe addition with division result\n    if (denominator > 0) {\n        result += dTerm / denominator;\n    }\n    \n    return result;\n}\n"})})}),(0,a.jsx)(s.A,{value:"cuberoot",label:"Cube Root",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-solidity",children:"/**\n * @notice Approximate the cube root of a number\n * @param x Value to calculate cube root of\n * @return Approximated cube root\n */\nfunction approximateCubeRoot(uint256 x) private pure returns (uint256) {\n    if (x == 0) return 0;\n    \n    // Initial guess (scaled by PRECISION)\n    uint256 y = x;\n    \n    // Newton's method for cube root\n    // y = y - (y^3 - x) / (3 * y^2)\n    // Simplified to: y = (2*y^3 + x) / (3*y^2)\n    \n    // Four iterations of Newton's method\n    for (uint256 i = 0; i < 4; i++) {\n        uint256 y3 = ((y * y) / PRECISION) * y / PRECISION;\n        uint256 y2 = (y * y) / PRECISION;\n        if (y2 == 0) return 0;\n        y = ((2 * y3) + x) / (3 * y2);\n    }\n    \n    return y;\n}\n"})})}),(0,a.jsx)(s.A,{value:"component2",label:"Component 2",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-solidity",children:"/**\n * @notice Approximate the second component of the Herm\xe8s formula\n * @param x Current jackpot size\n * @param cubeRoot Cube root from the first component\n * @return Approximate value of the second component\n */\nfunction approximateComponent2(uint256 x, uint256 cubeRoot) private pure returns (uint256) {\n    // Calculate x^2\n    uint256 x2 = (x * x) / PRECISION;\n    \n    // Calculate x^2 / (3 * cubeRoot)\n    if (cubeRoot == 0) return 0;\n    \n    uint256 denominator = 3 * cubeRoot;\n    uint256 result = (x2 * PRECISION) / denominator;\n    \n    return result;\n}\n"})})})]}),"\n",(0,a.jsxs)("div",{className:"gas-optimization",children:[(0,a.jsx)("h4",{children:"Gas Optimization Notes"}),(0,a.jsx)("p",{children:"The implementation is carefully optimized for gas efficiency:"}),(0,a.jsxs)("ul",{children:[(0,a.jsx)("li",{children:"Component-based approach divides the complex formula into manageable parts"}),(0,a.jsx)("li",{children:"Fixed number of iterations for Newton's method (4) balances precision with gas usage"}),(0,a.jsx)("li",{children:"Early exit conditions for edge cases such as zero values"}),(0,a.jsx)("li",{children:"Careful ordering of operations to maintain precision with minimal gas cost"}),(0,a.jsx)("li",{children:"Reuse of calculated values where possible (e.g., y\xb2, y\xb3)"})]})]}),"\n",(0,a.jsx)(n.h2,{id:"distribution-parameters",children:"Distribution Parameters"}),"\n",(0,a.jsx)(n.p,{children:"The library defines several constants for fee distribution and probability calculations:"}),"\n",(0,a.jsxs)(o.A,{children:[(0,a.jsx)(s.A,{value:"fees",label:"Fee Distribution",default:!0,children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-solidity",children:"// Base fee distribution (in basis points)\nuint256 constant public BASE_JACKPOT_BPS = 690;  // 69.0%\nuint256 constant public BASE_LP_BPS = 241;       // 24.1%\nuint256 constant public BASE_BURN_BPS = 69;      // 6.9%\n\n// Minimum allocations (in basis points)\nuint256 constant public MIN_JACKPOT_BPS = 400;   // 40.0% minimum to jackpot\nuint256 constant public MIN_LP_BPS = 150;        // 15.0% minimum to LPs\nuint256 constant public MIN_BURN_BPS = 30;       // 3.0% minimum burn\n"})})}),(0,a.jsx)(s.A,{value:"probability",label:"Win Probability",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-solidity",children:"// Win probability constants\nuint256 constant public BASE_WIN_PROB_BPS = 4;      // 0.0004% base probability\nuint256 constant public MAX_BASE_WIN_PROB_BPS = 400;  // 4% max base probability\nuint256 constant public MAX_BOOSTED_WIN_PROB_BPS = 1000; // 10% max boosted probability\n"})})}),(0,a.jsx)(s.A,{value:"boost",label:"Boost Parameters",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-solidity",children:"// Constants for boost calculations\nuint256 constant private BASE_BOOST_BPS = 10000; // 100% = 1.0x boost\nuint256 constant private MAX_BOOST_BPS = 25000;  // 250% = 2.5x max boost\nuint256 constant private MIN_LP_FOR_MAX_BOOST = 1000 ether; // 1000 LP tokens for max boost\n"})})})]}),"\n",(0,a.jsx)(n.h2,{id:"distribution-calculation",children:"Distribution Calculation"}),"\n",(0,a.jsx)(n.p,{children:"The library provides functions to calculate jackpot distributions:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-solidity",metastring:'title="Jackpot Distribution Calculator"',children:"/**\n * @notice Calculate jackpot distribution percentages\n * @param jackpotSize Current jackpot size\n * @param totalParticipants Number of lottery participants\n * @param params Additional parameters [0]=d, [1]=n, [2]=basePercentage, [3]=adjustmentFactor\n * @return mainPrize Percentage for main winner\n * @return secondaryPrize Percentage for secondary winners\n * @return participationRewards Percentage for participation rewards\n */\nfunction calculateJackpotDistribution(\n    uint256 jackpotSize,\n    uint256 totalParticipants,\n    uint256[4] memory params\n) internal pure returns (\n    uint256 mainPrize,\n    uint256 secondaryPrize,\n    uint256 participationRewards\n) {\n    // Default values\n    mainPrize = 69 * PRECISION / 100; // 69%\n    secondaryPrize = 24 * PRECISION / 100; // 24%\n    participationRewards = 7 * PRECISION / 100; // 7%\n    \n    // Apply the Herm\xe8s formula for dynamic distribution\n    if (jackpotSize > 0 && totalParticipants > 0) {\n        uint256 d = params[0];\n        uint256 n = params[1];\n        uint256 basePercentage = params[2];\n        uint256 adjustmentFactor = params[3];\n        \n        // Calculate the optimal distribution using Herm\xe8s formula\n        uint256 optimalDistribution = calculateHermesValue(jackpotSize, d, n);\n        \n        // Apply adjustment factor\n        uint256 adjustedValue = (optimalDistribution * adjustmentFactor) / PRECISION;\n        \n        // Calculate the dynamic distribution\n        mainPrize = basePercentage + adjustedValue;\n        \n        // Ensure total doesn't exceed 100%\n        if (mainPrize > 85 * PRECISION / 100) {\n            mainPrize = 85 * PRECISION / 100;\n        }\n        \n        // Adjust secondary and participation based on main prize\n        secondaryPrize = (100 * PRECISION / 100 - mainPrize) * 80 / 100;\n        participationRewards = 100 * PRECISION / 100 - mainPrize - secondaryPrize;\n    }\n    \n    return (mainPrize, secondaryPrize, participationRewards);\n}\n"})}),"\n",(0,a.jsxs)("div",{className:"return-value",children:[(0,a.jsx)("strong",{children:"Return Values:"}),(0,a.jsxs)("ul",{children:[(0,a.jsxs)("li",{children:[(0,a.jsx)("code",{children:"mainPrize"}),": Percentage allocated to the main jackpot winner (scaled by PRECISION)"]}),(0,a.jsxs)("li",{children:[(0,a.jsx)("code",{children:"secondaryPrize"}),": Percentage allocated to secondary winners (scaled by PRECISION)"]}),(0,a.jsxs)("li",{children:[(0,a.jsx)("code",{children:"participationRewards"}),": Percentage allocated to participation rewards (scaled by PRECISION)"]})]})]}),"\n",(0,a.jsx)(n.h2,{id:"win-probability-calculation",children:"Win Probability Calculation"}),"\n",(0,a.jsx)(n.p,{children:"The library also provides functions to calculate win probabilities:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-solidity",metastring:'title="Win Probability Calculator"',children:"/**\n * @notice Calculate win probability based on swap size\n * @param swapAmount Amount being swapped (in base units)\n * @param tokenPrice Current token price\n * @param userBoost User's boost multiplier (in BPS)\n * @return Probability of winning (in BPS)\n */\nfunction calculateWinProbability(\n    uint256 swapAmount,\n    uint256 tokenPrice,\n    uint256 userBoost\n) internal pure returns (uint256) {\n    // Convert swap amount to USD value\n    uint256 swapValueUsd = (swapAmount * tokenPrice) / PRECISION;\n    \n    // Base probability follows logarithmic curve\n    uint256 baseProbability;\n    \n    if (swapValueUsd < 10 * PRECISION) {\n        // Swaps under $10 get minimum probability\n        baseProbability = BASE_WIN_PROB_BPS;\n    } else if (swapValueUsd >= 10000 * PRECISION) {\n        // Swaps over $10,000 get maximum probability\n        baseProbability = MAX_BASE_WIN_PROB_BPS;\n    } else {\n        // Logarithmic scaling for values in between\n        uint256 logFactor = logarithmicScaling(swapValueUsd, 10 * PRECISION, 10000 * PRECISION);\n        baseProbability = BASE_WIN_PROB_BPS + \n            (logFactor * (MAX_BASE_WIN_PROB_BPS - BASE_WIN_PROB_BPS)) / PRECISION;\n    }\n    \n    // Apply user boost\n    uint256 boostedProbability = (baseProbability * userBoost) / BASE_BOOST_BPS;\n    \n    // Cap at maximum boosted probability\n    if (boostedProbability > MAX_BOOSTED_WIN_PROB_BPS) {\n        return MAX_BOOSTED_WIN_PROB_BPS;\n    }\n    \n    return boostedProbability;\n}\n"})}),"\n",(0,a.jsxs)("div",{className:"return-value",children:[(0,a.jsx)("strong",{children:"Return Value:"}),(0,a.jsx)("p",{children:"Win probability in basis points (1 BPS = 0.01%). A value of 100 represents a 1% probability."})]}),"\n",(0,a.jsx)(n.h2,{id:"integration-examples",children:"Integration Examples"}),"\n",(0,a.jsx)(n.h3,{id:"jackpot-distribution-system",children:"Jackpot Distribution System"}),"\n",(0,a.jsxs)(o.A,{children:[(0,a.jsx)(s.A,{value:"distributor",label:"Jackpot Distributor",default:!0,children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-solidity",children:'// Import the library\nimport "../math/HermesMath.sol";\n\ncontract JackpotDistributor {\n    using HermesMath for uint256;\n    \n    // Protocol constants (can be adjusted by governance)\n    uint256 public d = 3 * 1e18; // Protocol constant D\n    uint256 public n = 2 * 1e18; // Protocol constant N\n    uint256 public basePercentage = 60 * 1e18 / 100; // 60%\n    uint256 public adjustmentFactor = 8 * 1e17; // 0.8\n    \n    // Calculate prize distribution for current jackpot\n    function calculatePrizes(uint256 jackpotSize, uint256 participants) external view returns (\n        uint256 mainPrize,\n        uint256 secondaryPrize,\n        uint256 participationRewards\n    ) {\n        uint256[4] memory params = [d, n, basePercentage, adjustmentFactor];\n        \n        return HermesMath.calculateJackpotDistribution(\n            jackpotSize,\n            participants,\n            params\n        );\n    }\n    \n    // Calculate win probability for a swap\n    function calculateSwapWinProbability(\n        uint256 swapAmount,\n        uint256 tokenPrice,\n        uint256 userBoost\n    ) external pure returns (uint256) {\n        return HermesMath.calculateWinProbability(\n            swapAmount,\n            tokenPrice,\n            userBoost\n        );\n    }\n}\n'})})}),(0,a.jsx)(s.A,{value:"feedistributor",label:"Fee Distributor",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-solidity",children:'// Import the library\nimport "../math/HermesMath.sol";\n\ncontract FeeDistributor {\n    using HermesMath for uint256;\n    \n    // Distribute fees according to the HermesMath parameters\n    function distributeFees(uint256 feeAmount) external returns (\n        uint256 toJackpot,\n        uint256 toLps,\n        uint256 toBurn\n    ) {\n        toJackpot = (feeAmount * HermesMath.BASE_JACKPOT_BPS) / HermesMath.BPS_MAX;\n        toLps = (feeAmount * HermesMath.BASE_LP_BPS) / HermesMath.BPS_MAX;\n        toBurn = (feeAmount * HermesMath.BASE_BURN_BPS) / HermesMath.BPS_MAX;\n        \n        // Send to respective destinations\n        // ...\n        \n        return (toJackpot, toLps, toBurn);\n    }\n}\n'})})})]}),"\n",(0,a.jsx)(n.h2,{id:"mathematical-background",children:"Mathematical Background"}),"\n",(0,a.jsx)(n.h3,{id:"the-herm\xe8s-distribution-model",children:"The Herm\xe8s Distribution Model"}),"\n",(0,a.jsx)(n.p,{children:"The Herm\xe8s formula was designed specifically for the Sonic Red Dragon jackpot system with these properties:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Balance"}),": Finds the optimal balance between jackpot growth and payout frequency"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Scale Sensitivity"}),": Distribution changes based on jackpot size"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Governance Control"}),": Parameters d and n allow governance to tune the system"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Stability"}),": Ensures stable growth even with volatile participation rates"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"numerical-properties",children:"Numerical Properties"}),"\n",(0,a.jsx)(n.p,{children:"The formula has several interesting numerical properties:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"As jackpot size (x) increases, the formula yields larger absolute values"}),"\n",(0,a.jsx)(n.li,{children:'The growth rate is non-linear, creating a natural "jackpot momentum" effect'}),"\n",(0,a.jsx)(n.li,{children:"Parameter d controls the baseline distribution rate"}),"\n",(0,a.jsx)(n.li,{children:"Parameter n controls the sensitivity to jackpot size changes"}),"\n"]}),"\n",(0,a.jsxs)("div",{className:"security-consideration",children:[(0,a.jsx)("h4",{children:"Security Considerations"}),(0,a.jsx)("p",{children:"When using the HermesMath library, consider these security best practices:"}),(0,a.jsxs)("ul",{children:[(0,a.jsxs)("li",{children:[(0,a.jsx)("strong",{children:"Parameter Bounds"}),": Ensure governance parameters d and n stay within reasonable bounds"]}),(0,a.jsxs)("li",{children:[(0,a.jsx)("strong",{children:"Precision Consistency"}),": Maintain consistent precision factors across calculations"]}),(0,a.jsxs)("li",{children:[(0,a.jsx)("strong",{children:"Reserve Requirements"}),": Ensure the contract has sufficient reserves to pay calculated prizes"]}),(0,a.jsxs)("li",{children:[(0,a.jsx)("strong",{children:"Update Control"}),": Implement careful controls around updating the distribution parameters"]}),(0,a.jsxs)("li",{children:[(0,a.jsx)("strong",{children:"Max Cap"}),": Consider implementing maximum caps on individual prizes for security"]})]})]})]})}function m(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(p,{...e})}):p(e)}},5537:(e,n,t)=>{t.d(n,{A:()=>v});var i=t(6540),a=t(4164),r=t(5627),o=t(6347),s=t(372),l=t(604),c=t(1861),u=t(8749);function d(e){return i.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,i.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function p(e){const{values:n,children:t}=e;return(0,i.useMemo)((()=>{const e=n??function(e){return d(e).map((({props:{value:e,label:n,attributes:t,default:i}})=>({value:e,label:n,attributes:t,default:i})))}(t);return function(e){const n=(0,c.XI)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,t])}function m({value:e,tabValues:n}){return n.some((n=>n.value===e))}function h({queryString:e=!1,groupId:n}){const t=(0,o.W6)(),a=function({queryString:e=!1,groupId:n}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:e,groupId:n});return[(0,l.aZ)(a),(0,i.useCallback)((e=>{if(!a)return;const n=new URLSearchParams(t.location.search);n.set(a,e),t.replace({...t.location,search:n.toString()})}),[a,t])]}function b(e){const{defaultValue:n,queryString:t=!1,groupId:a}=e,r=p(e),[o,l]=(0,i.useState)((()=>function({defaultValue:e,tabValues:n}){if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!m({value:e,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const t=n.find((e=>e.default))??n[0];if(!t)throw new Error("Unexpected error: 0 tabValues");return t.value}({defaultValue:n,tabValues:r}))),[c,d]=h({queryString:t,groupId:a}),[b,x]=function({groupId:e}){const n=function(e){return e?`docusaurus.tab.${e}`:null}(e),[t,a]=(0,u.Dv)(n);return[t,(0,i.useCallback)((e=>{n&&a.set(e)}),[n,a])]}({groupId:a}),f=(()=>{const e=c??b;return m({value:e,tabValues:r})?e:null})();(0,s.A)((()=>{f&&l(f)}),[f]);return{selectedValue:o,selectValue:(0,i.useCallback)((e=>{if(!m({value:e,tabValues:r}))throw new Error(`Can't select invalid tab value=${e}`);l(e),d(e),x(e)}),[d,x,r]),tabValues:r}}var x=t(9136);const f={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var j=t(4848);function P({className:e,block:n,selectedValue:t,selectValue:i,tabValues:o}){const s=[],{blockElementScrollPositionUntilNextRender:l}=(0,r.a_)(),c=e=>{const n=e.currentTarget,a=s.indexOf(n),r=o[a].value;r!==t&&(l(n),i(r))},u=e=>{let n=null;switch(e.key){case"Enter":c(e);break;case"ArrowRight":{const t=s.indexOf(e.currentTarget)+1;n=s[t]??s[0];break}case"ArrowLeft":{const t=s.indexOf(e.currentTarget)-1;n=s[t]??s[s.length-1];break}}n?.focus()};return(0,j.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,a.A)("tabs",{"tabs--block":n},e),children:o.map((({value:e,label:n,attributes:i})=>(0,j.jsx)("li",{role:"tab",tabIndex:t===e?0:-1,"aria-selected":t===e,ref:e=>{s.push(e)},onKeyDown:u,onClick:c,...i,className:(0,a.A)("tabs__item",f.tabItem,i?.className,{"tabs__item--active":t===e}),children:n??e},e)))})}function g({lazy:e,children:n,selectedValue:t}){const r=(Array.isArray(n)?n:[n]).filter(Boolean);if(e){const e=r.find((e=>e.props.value===t));return e?(0,i.cloneElement)(e,{className:(0,a.A)("margin-top--md",e.props.className)}):null}return(0,j.jsx)("div",{className:"margin-top--md",children:r.map(((e,n)=>(0,i.cloneElement)(e,{key:n,hidden:e.props.value!==t})))})}function y(e){const n=b(e);return(0,j.jsxs)("div",{className:(0,a.A)("tabs-container",f.tabList),children:[(0,j.jsx)(P,{...n,...e}),(0,j.jsx)(g,{...n,...e})]})}function v(e){const n=(0,x.A)();return(0,j.jsx)(y,{...e,children:d(e.children)},String(n))}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>s});var i=t(6540);const a={},r=i.createContext(a);function o(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),i.createElement(r.Provider,{value:n},e.children)}},9329:(e,n,t)=>{t.d(n,{A:()=>o});t(6540);var i=t(4164);const a={tabItem:"tabItem_Ymn6"};var r=t(4848);function o({children:e,hidden:n,className:t}){return(0,r.jsx)("div",{role:"tabpanel",className:(0,i.A)(a.tabItem,t),hidden:n,children:e})}}}]);